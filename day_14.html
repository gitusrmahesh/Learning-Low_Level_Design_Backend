<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate Guide to C# Multithreading</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals with Teal Accent -->
    <!-- Application Structure Plan: The application has been expanded into a comprehensive, single-page educational guide covering a full C# multithreading curriculum. The structure uses a sticky right-hand table of contents for easy navigation through an expanded set of thematic sections (Core Concepts, Concurrency Hazards, Synchronization Primitives, Advanced Topics, etc.). This deep-dive structure allows users to treat the page as both a linear lesson and a quick-reference guide. Content is logically grouped and presented in collapsible sections with analogies, syntax snippets, and interactive elements to make complex topics digestible and engaging. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Performance vs. Safety -> Goal: Visually demonstrate this core trade-off. -> Viz/Presentation: Interactive Bar Chart (Chart.js) controlled by a slider. -> Interaction: User adjusts "Synchronization Level," and chart updates in real-time. -> Justification: Makes an abstract concept tangible. -> Library/Method: Chart.js/Canvas.
        - Report Info: Race Condition -> Goal: Show how unsynchronized access corrupts data. -> Viz/Presentation: A "Run Simulation" button with two output columns. -> Interaction: Simulation animates two threads concurrently trying to increment a counter, visually showing the incorrect, jumbled result. -> Justification: Provides a dynamic, intuitive visualization of a common concurrency bug. -> Library/Method: Vanilla JS DOM manipulation.
        - Report Info: Thread Pool Execution -> Goal: Explain task lifecycle. -> Viz/Presentation: HTML/CSS-based Activity Diagram. -> Interaction: Hovering over steps reveals tooltips with explanations. -> Justification: An accessible, non-library way to create a UML-style diagram. -> Library/Method: HTML/Tailwind CSS.
        - Report Info: All other theoretical topics (Async/Await, Deadlocks, Mutex, ReaderWriterLockSlim, Concurrent Collections) -> Goal: Explain complex concepts clearly. -> Viz/Presentation: Detailed text with analogies, syntax snippets, and in-depth explanations within collapsible sections. -> Interaction: Users can expand/collapse topics of interest. -> Justification: This classic documentation pattern keeps the UI clean while providing deep information on demand. -> Library/Method: HTML/JS.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f4; /* stone-100 */
            color: #44403c; /* stone-700 */
        }
        .toc-link.active {
            color: #0d9488; /* teal-600 */
            font-weight: 600;
            border-left-color: #0d9488; /* teal-600 */
        }
        .toc-link-sub {
            padding-left: 1.5rem; /* For indentation */
            font-size: 0.9rem;
        }
        .code-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #e7e5e4; /* stone-200 */
            color: #57534e; /* stone-600 */
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10;
        }
        .copy-button:hover {
            background-color: #a8a29e; /* stone-400 */
            color: #1c1917; /* stone-900 */
        }
        .quiz-option.correct {
            background-color: #d1fae5; /* green-100 */
            border-color: #10b981; /* green-500 */
        }
        .quiz-option.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        pre {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div class="flex-grow">
        <!-- CUSTOM HEADER GAP -->
        <div class="h-16"></div>

        <div class="container mx-auto px-4 py-8">
            <header class="text-center mb-12">
                <h1 class="text-4xl md:text-5xl font-bold text-stone-800">The Ultimate Guide to C# Multithreading</h1>
                <p class="text-lg text-stone-600 mt-2">From Fundamentals to Advanced Concepts</p>
            </header>

            <div class="flex flex-col lg:flex-row gap-8">
                <!-- Main Content -->
                <main class="w-full lg:w-3/4">
                    
                    <section id="introduction" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">Introduction</h2>
                        <p class="mb-4 text-stone-600">Welcome to this comprehensive guide on C# multithreading. This module covers everything you need to know to write efficient, responsive, and robust concurrent applications. We will journey from the basic building blocks like Threads and Tasks, through the common dangers of race conditions and deadlocks, and into the advanced synchronization techniques and collections that enable powerful parallel processing. Whether you are a beginner or looking to solidify your knowledge, this all-in-one resource is designed for you.</p>
                    </section>
                    
                    <section id="core" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">Core Concepts</h2>
                        <p class="mb-8 text-stone-600">This section covers the foundational elements of concurrent execution in C#. Understanding the distinction between Threads, Tasks, and the Async/Await pattern is the first step toward writing modern asynchronous code.</p>
                        <div class="space-y-6">
                             <details class="bg-white p-4 rounded-lg shadow-sm" open>
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Threads</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A <code class="bg-stone-200 rounded px-1">Thread</code> is a single worker in a factory. It represents an independent path of execution. Creating a new thread is like hiring a new worker; it's a relatively "heavy" operation for the operating system.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">Thread worker = new Thread(() => {
    Console.WriteLine("Executing work on a new thread.");
    Thread.Sleep(1000);
});
worker.Start();
worker.Join(); // Main thread waits for the worker to finish.
</code></pre>
                                    </div>
                                </div>
                            </details>
                            <details class="bg-white p-4 rounded-lg shadow-sm" open>
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Tasks</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A <code class="bg-stone-200 rounded px-1">Task</code> is a modern, smarter assignment sheet for a worker. You don't hire a specific worker; you post the assignment, and the factory manager (the .NET Thread Pool) gives it to the next available worker. This is much more efficient than hiring a new worker for every small job.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">Task myTask = Task.Run(() => {
    Console.WriteLine("Executing work via the Thread Pool.");
});
myTask.Wait(); // Main thread waits for the task to complete.
</code></pre>
                                    </div>
                                </div>
                            </details>
                            <details class="bg-white p-4 rounded-lg shadow-sm" open>
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Async / Await</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A chef in a kitchen wants to make a stew. They put the stew on the stove to simmer (an I/O-bound operation, like a web request). Instead of staring at the pot, the chef <code class="bg-stone-200 rounded px-1">awaits</code> the stew and starts chopping vegetables for another dish. The thread is freed up. When the stew is ready, a timer (the system) notifies the chef, who can then continue working on the stew. This pattern is perfect for I/O operations and keeps applications (especially UIs) responsive.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">public async Task FetchDataAsync()
{
    Console.WriteLine("Starting data fetch...");
    // The 'await' keyword frees up the calling thread.
    // It doesn't block, it just yields control.
    var data = await new HttpClient().GetStringAsync("https://api.example.com/data");
    Console.WriteLine("Data fetched successfully.");
    // Code here will execute after the download is complete.
}
</code></pre>
                                    </div>
                                </div>
                            </details>
                        </div>
                    </section>

                    <section id="hazards" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">Concurrency Hazards</h2>
                        <p class="mb-8 text-stone-600">When multiple threads interact with shared resources, new classes of bugs emerge. Understanding race conditions and deadlocks is absolutely critical for writing correct concurrent programs.</p>
                        <div class="space-y-6">
                            <div class="bg-white p-6 rounded-lg shadow-sm">
                                <h3 class="text-xl font-semibold text-stone-700">Race Conditions</h3>
                                <p class="text-stone-600 my-2"><strong class="text-stone-700">Analogy:</strong> Two cashiers are using the same cash register display. Cashier 1 reads the total: $50. Before they can add a $10 item, Cashier 2 also reads the total: $50. Cashier 1 adds $10, updates the total to $60. Cashier 2 then adds a $5 item to the $50 they read, and updates the total to $55. The final total is wrong because the read-modify-write sequence was interleaved incorrectly.</p>
                                <div class="flex flex-col md:flex-row gap-4 mt-4">
                                    <div class="w-full md:w-1/2">
                                        <h4 class="font-semibold text-stone-800 mb-2">Simulation of a Race Condition</h4>
                                        <p class="text-sm text-stone-500 mb-2">Two threads will try to increment a counter to 20. See the unpredictable result.</p>
                                        <button id="runRaceSimButton" class="bg-teal-600 text-white px-4 py-2 rounded-md hover:bg-teal-700 transition">Run Simulation</button>
                                        <div id="raceOutput" class="h-48 bg-stone-100 p-2 rounded overflow-y-auto mt-2 font-mono text-xs"></div>
                                    </div>
                                    <div class="w-full md:w-1/2">
                                        <h4 class="font-semibold text-stone-800 mb-2">Fixing It with a Lock</h4>
                                        <p class="text-sm text-stone-500 mb-2">A lock ensures the read-modify-write operation is atomic.</p>
                                        <div class="code-block mt-2">
                                            <button class="copy-button">Copy</button>
                                            <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">private int _counter = 0;
private readonly object _lock = new object();

public void Increment()
{
    // Without lock: Race condition!
    // _counter++;

    // With lock: Thread-safe
    lock(_lock)
    {
        _counter++;
    }
}
</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <details class="bg-white p-4 rounded-lg shadow-sm">
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Deadlocks</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> Two people are at a table with a single fork and a single knife. Person A picks up the fork. Person B picks up the knife. Now, Person A is waiting for the knife (held by B), and Person B is waiting for the fork (held by A). Neither can proceed, and they will wait forever. This is a deadlock.</p>
                                    <p>A deadlock occurs when two or more threads are blocked forever, each waiting for a resource held by another thread in the cycle. The "Dining Philosophers" problem in the final challenge section is a classic example of this.</p>
                                    <h4 class="font-semibold">Prevention Strategy</h4>
                                    <p>The most common way to prevent deadlocks is to enforce a strict order for acquiring locks. If all threads must lock resources A, B, and C in that exact order, a circular wait is impossible.</p>
                                </div>
                            </details>
                        </div>
                    </section>
                    
                    <section id="sync" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">Synchronization Primitives</h2>
                        <p class="mb-8 text-stone-600">To prevent concurrency hazards, C# provides a rich set of tools called synchronization primitives. Each tool is designed for a specific scenario, from simple exclusive access to complex coordination between many threads.</p>
                        <div class="space-y-6">
                            <details class="bg-white p-4 rounded-lg shadow-sm">
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">lock (Monitor)</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A key to a single restroom. Only one thread can hold the key (<code class="bg-stone-200 rounded px-1">lock</code>) and enter the critical section at a time. It's the simplest and most common way to ensure mutual exclusion within a single application.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">private readonly object _balanceLock = new object();
public void UpdateBalance(decimal amount)
{
    lock (_balanceLock)
    {
        // Safely read, modify, and write the balance.
    }
}
</code></pre>
                                    </div>
                                </div>
                            </details>
                             <details class="bg-white p-4 rounded-lg shadow-sm">
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Mutex</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A special, system-wide "talking stick." A <code class="bg-stone-200 rounded px-1">Mutex</code> is like a <code class="bg-stone-200 rounded px-1">lock</code>, but it can work across different processes. For example, you could use it to ensure that only one instance of your entire application can run on a machine at a time.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">// A named mutex is visible across the entire OS.
private static Mutex _mutex = new Mutex(false, "MyUniqueAppNameMutex");

public void PerformSystemWideAction()
{
    if (_mutex.WaitOne(TimeSpan.FromSeconds(5))) // Try to acquire the mutex
    {
        try { /* Critical section for cross-process work */ }
        finally { _mutex.ReleaseMutex(); }
    }
    else { /* Could not acquire the lock */ }
}
</code></pre>
                                    </div>
                                </div>
                            </details>
                             <details class="bg-white p-4 rounded-lg shadow-sm">
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Semaphore / SemaphoreSlim</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A bike rental station with 5 bikes. A <code class="bg-stone-200 rounded px-1">Semaphore</code> allows a specific number of threads (e.g., 5) to access a resource pool concurrently. The 6th thread must wait until one of the first 5 returns their "bike" (<code class="bg-stone-200 rounded px-1">Release()</code>). <code class="bg-stone-200 rounded px-1">SemaphoreSlim</code> is a faster, lightweight version for use within a single application.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">// Limit concurrent access to a network resource to 10 threads.
private SemaphoreSlim _apiLimiter = new SemaphoreSlim(10, 10);

public async Task CallApiAsync()
{
    await _apiLimiter.WaitAsync();
    try
    {
        // Make the network call
    }
    finally
    {
        _apiLimiter.Release();
    }
}
</code></pre>
                                    </div>
                                </div>
                            </details>
                             <details class="bg-white p-4 rounded-lg shadow-sm">
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">ReaderWriterLockSlim</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A library's rare book room. Many people (reader threads) can be inside reading at the same time. However, if one person needs to update the book (a writer thread), they must request exclusive access. The librarian locks the door, waits for all readers to leave, lets the writer in, and then locks the door again. New readers must wait outside until the writer is finished. This is highly efficient for data that is read often but written to infrequently.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">private ReaderWriterLockSlim _cacheLock = new ReaderWriterLockSlim();
private Dictionary<string, object> _cache = new Dictionary<string, object>();

public object ReadFromCache(string key)
{
    _cacheLock.EnterReadLock();
    try { return _cache.GetValueOrDefault(key); }
    finally { _cacheLock.ExitReadLock(); }
}

public void WriteToCache(string key, object value)
{
    _cacheLock.EnterWriteLock();
    try { _cache[key] = value; }
    finally { _cacheLock.ExitWriteLock(); }
}
</code></pre>
                                    </div>
                                </div>
                            </details>
                        </div>
                    </section>
                    
                    <section id="advanced" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">Advanced Topics & Patterns</h2>
                        <p class="mb-8 text-stone-600">Building on the primitives, we can explore higher-level constructs and design patterns that simplify concurrent programming and provide robust, out-of-the-box solutions.</p>
                        <div class="space-y-6">
                             <details class="bg-white p-4 rounded-lg shadow-sm">
                                <summary class="font-semibold text-lg cursor-pointer text-stone-700">Thread-Safe Collections</summary>
                                <div class="mt-4 text-stone-600 space-y-4">
                                    <p><strong class="text-stone-700">Analogy:</strong> A self-organizing mailbox system. With a normal <code class="bg-stone-200 rounded px-1">List&lt;T&gt;</code> or <code class="bg-stone-200 rounded px-1">Dictionary</code>, if two mail carriers try to add mail at the same time, they might interfere and create a mess. The collections in <code class="bg-stone-200 rounded px-1">System.Collections.Concurrent</code> are designed with internal locking mechanisms, so multiple threads can safely add, remove, and update items at the same time without extra locks.</p>
                                    <div class="code-block">
                                        <button class="copy-button">Copy</button>
                                        <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">using System.Collections.Concurrent;

// A dictionary where multiple threads can safely add/update keys.
ConcurrentDictionary<string, int> userScores = new ConcurrentDictionary<string, int>();

// Multiple threads can call this method without external locks.
public void UpdateScore(string userId, int score)
{
    userScores.AddOrUpdate(userId, score, (key, existingScore) => existingScore + score);
}
</code></pre>
                                    </div>
                                </div>
                            </details>
                            <div class="bg-white p-6 rounded-lg shadow-sm">
                                <h3 class="text-xl font-semibold text-stone-700 mb-4">Interactive: The Performance vs. Safety Trade-off</h3>
                                <p class="mb-4 text-stone-600">Using synchronization primitives introduces overhead. The more you lock to ensure safety, the more you can potentially slow down your application because threads have to wait. This visualization illustrates that inverse relationship. Move the slider to see how increasing synchronization impacts performance.</p>
                                <div class="chart-container">
                                    <canvas id="perfSafetyChart"></canvas>
                                </div>
                                <div class="mt-4">
                                    <label for="syncLevel" class="block mb-2 text-sm font-medium text-stone-900">Synchronization Level</label>
                                    <input id="syncLevel" type="range" min="1" max="100" value="20" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                            <div class="grid md:grid-cols-2 gap-8">
                                <div class="bg-white p-6 rounded-lg shadow-sm">
                                    <h3 class="text-xl font-semibold text-stone-700 mb-2">Producer-Consumer Pattern</h3>
                                    <p class="text-stone-600">One or more "producer" threads generate data and place it into a shared thread-safe queue (like <code class="bg-stone-200 rounded px-1">BlockingCollection&lt;T&gt;</code>), while one or more "consumer" threads pull data from the queue and process it. This decouples work generation from work execution.</p>
                                </div>
                                <div class="bg-white p-6 rounded-lg shadow-sm">
                                    <h3 class="text-xl font-semibold text-stone-700 mb-2">Thread Pools</h3>
                                    <p class="text-stone-600">A "pool" of worker threads is created upfront to execute tasks. Instead of creating a new thread for every task (which is expensive), tasks are queued and assigned to an available thread from the pool. This minimizes overhead. C#'s <code class="bg-stone-200 rounded px-1">Task.Run</code> uses the built-in thread pool.</p>
                                </div>
                            </div>
                        </div>
                    </section>
                    
                    <section id="coding" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">✅ Coding Practice & Solutions</h2>
                        <p class="mb-8 text-stone-600">Theory is important, but mastery comes from practice. This section contains several coding problems ranging in difficulty. Each includes a full C# solution.</p>
                        <!-- Problems are the same as before, no changes needed here -->
                         <div class="bg-white p-6 rounded-lg shadow-sm mb-6">
                            <h3 class="text-xl font-semibold text-stone-700">[Easy] Print 1–100 with 2 Threads Alternately</h3>
                            <details class="mt-4">
                                <summary class="cursor-pointer text-teal-600">Show Full Solution</summary>
                                <div class="code-block mt-2">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-stone-800 text-white p-4 rounded-md text-sm max-h-64 overflow-y-auto"><code class="language-csharp">public class AlternatePrinter
{
    private readonly object _lock = new object();
    private bool _isOddTurn = true;

    public void PrintNumbers()
    {
        Thread oddThread = new Thread(PrintOdd);
        Thread evenThread = new Thread(PrintEven);

        oddThread.Start();
        Thread.Sleep(10); 
        evenThread.Start();

        oddThread.Join();
        evenThread.Join();
    }

    private void PrintOdd()
    {
        for (int i = 1; i <= 100; i += 2)
        {
            lock (_lock)
            {
                while (!_isOddTurn) Monitor.Wait(_lock);
                Console.WriteLine($"Thread 1 (Odd): {i}");
                _isOddTurn = false;
                Monitor.Pulse(_lock);
            }
        }
    }

    private void PrintEven()
    {
        for (int i = 2; i <= 100; i += 2)
        {
            lock (_lock)
            {
                while (_isOddTurn) Monitor.Wait(_lock);
                Console.WriteLine($"Thread 2 (Even): {i}");
                _isOddTurn = true;
                Monitor.Pulse(_lock);
            }
        }
    }
}
</code></pre>
                                </div>
                            </details>
                        </div>
                        <details class="bg-white p-4 rounded-lg shadow-sm mb-6">
                            <summary class="font-semibold text-lg cursor-pointer text-stone-700">[Medium] Multi-threaded Download Manager</summary>
                             <div class="mt-4 text-stone-600 space-y-4">
                                <p>Design a manager that can download multiple files concurrently, using a semaphore to limit the number of simultaneous downloads.</p>
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">public class DownloadManager
{
    private readonly SemaphoreSlim _semaphore;
    public DownloadManager(int maxConcurrentDownloads) { _semaphore = new SemaphoreSlim(maxConcurrentDownloads); }

    public async Task DownloadFilesAsync(IEnumerable<string> urls)
    {
        var downloadTasks = urls.Select(url => DownloadFileInternalAsync(url));
        await Task.WhenAll(downloadTasks);
    }

    private async Task DownloadFileInternalAsync(string url)
    {
        await _semaphore.WaitAsync();
        try
        {
            Console.WriteLine($"Starting: {url}");
            using var client = new HttpClient();
            var data = await client.GetByteArrayAsync(url);
            Console.WriteLine($"Finished: {url}, Size: {data.Length} bytes");
        }
        finally { _semaphore.Release(); }
    }
}
</code></pre>
                                </div>
                            </div>
                        </details>
                        <details class="bg-white p-4 rounded-lg shadow-sm">
                            <summary class="font-semibold text-lg cursor-pointer text-stone-700">[Hard] Implement Mini Thread Pool</summary>
                            <div class="mt-4 text-stone-600 space-y-4">
                                <p>Implement a basic fixed-size thread pool with a task queue and worker threads.</p>
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">using System.Collections.Concurrent;
public class MiniThreadPool : IDisposable
{
    private readonly BlockingCollection<Action> _tasks = new BlockingCollection<Action>();
    private readonly List<Thread> _workers;

    public MiniThreadPool(int threadCount)
    {
        _workers = new List<Thread>(threadCount);
        for (int i = 0; i < threadCount; i++)
        {
            var worker = new Thread(WorkerLoop) { IsBackground = true };
            worker.Start();
            _workers.Add(worker);
        }
    }

    public void QueueUserWorkItem(Action work) => _tasks.Add(work);

    private void WorkerLoop()
    {
        foreach (var task in _tasks.GetConsumingEnumerable())
        {
            task?.Invoke();
        }
    }

    public void Dispose()
    {
        _tasks.CompleteAdding();
        foreach (var worker in _workers) worker.Join();
        _tasks.Dispose();
    }
}
</code></pre>
                                </div>
                            </div>
                        </details>
                    </section>

                    <section id="design" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">System Design & Case Study</h2>
                         <p class="mb-8 text-stone-600">Applying these concepts to build larger systems is the ultimate goal. Here we visualize a process flow and break down a common real-world design problem.</p>
                         <div class="bg-white p-6 rounded-lg shadow-sm mb-8">
                            <h3 class="text-xl font-semibold text-stone-700 mb-4">Activity Diagram: Thread Pool Execution</h3>
                            <div class="flex flex-col items-center space-y-2 font-sans text-sm">
                                <div class="relative group bg-blue-100 text-blue-800 p-3 rounded-lg shadow w-64 text-center">Start</div>
                                <div class="text-2xl text-stone-500">↓</div>
                                <div class="relative group bg-teal-100 text-teal-800 p-3 rounded-lg shadow w-64 text-center">Task Queued</div>
                                <div class="text-2xl text-stone-500">↓</div>
                                 <div class="relative group bg-yellow-100 text-yellow-800 p-3 rounded-lg shadow w-64 text-center border-2 border-dashed border-yellow-400">Worker Thread Waits</div>
                                <div class="text-2xl text-stone-500">↓</div>
                                <div class="relative group bg-green-100 text-green-800 p-3 rounded-lg shadow w-64 text-center">Task Dequeued & Executed</div>
                                <div class="text-2xl text-stone-500">↓</div>
                                 <div class="relative group bg-stone-200 text-stone-800 p-3 rounded-lg shadow w-64 text-center">Execution Complete (Loops back to wait)</div>
                            </div>
                        </div>
                        <details class="bg-white p-4 rounded-lg shadow-sm">
                            <summary class="font-semibold text-lg cursor-pointer text-stone-700">Case Study: Async Notification System</summary>
                             <div class="mt-4 text-stone-600 space-y-4">
                                <p><strong>Problem:</strong> Design a system to send notifications (email, SMS) without blocking the main application. It must be resilient to failures and support retries.</p>
                                <ul class="list-disc list-inside space-y-2">
                                    <li><strong>Notification Queue:</strong> Use a <code class="bg-stone-200 rounded px-1">BlockingCollection&lt;T&gt;</code>. Main app threads (producers) add notification requests to this queue instantly.</li>
                                    <li><strong>Worker Service:</strong> A background service with multiple long-running tasks (consumers). Each worker pulls from the queue and attempts to send the notification.</li>
                                    <li><strong>Retry Logic:</strong> If sending fails, re-queue the item with an increased delay counter. After 3-5 retries, move it to a "dead-letter" queue for manual inspection.</li>
                                </ul>
                            </div>
                        </details>
                    </section>
                    
                    <section id="quiz" class="mb-12 scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">🧠 Knowledge Check Quiz</h2>
                        <p class="mb-8 text-stone-600">Time to test your understanding. Select the best answer for each question and submit to see your results.</p>
                        <form id="quizForm" class="bg-white p-6 rounded-lg shadow-sm space-y-6">
                            <!-- Questions 1-4 -->
                            <div><p class="font-semibold text-stone-800">1. What is the primary purpose of the `lock` keyword?</p><div class="mt-2 space-y-2"><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q1" value="b" class="mr-2"> To ensure only one thread can execute a block of code at a time.</label><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q1" value="c" class="mr-2"> To limit concurrent access to a specific count (e.g., 5).</label></div></div>
                            <div><p class="font-semibold text-stone-800">2. You need to allow up to 10 concurrent threads to access a database connection pool. Which primitive is best?</p><div class="mt-2 space-y-2"><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q2" value="a" class="mr-2"> `lock`</label><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q2" value="c" class="mr-2"> `SemaphoreSlim`</label></div></div>
                            <div><p class="font-semibold text-stone-800">3. In the Producer-Consumer pattern, what is the role of the shared queue?</p><div class="mt-2 space-y-2"><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q3" value="a" class="mr-2"> To execute tasks directly.</label><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q3" value="b" class="mr-2"> To act as a thread-safe buffer between producers and consumers.</label></div></div>
                            <div><p class="font-semibold text-stone-800">4. Why is `Task.Run` preferred over `new Thread()`?</p><div class="mt-2 space-y-2"><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q4" value="c" class="mr-2"> It efficiently uses the thread pool, reducing overhead.</label><label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q4" value="d" class="mr-2"> It automatically handles all exceptions.</label></div></div>
                            <!-- New Questions -->
                             <div>
                                <p class="font-semibold text-stone-800">5. When is `ReaderWriterLockSlim` a more performant choice than a standard `lock`?</p>
                                <div class="mt-2 space-y-2">
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q5" value="a" class="mr-2"> For data that is written to far more often than it is read.</label>
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q5" value="b" class="mr-2"> When you need to synchronize access across multiple processes.</label>
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q5" value="c" class="mr-2"> For data that is read very frequently but modified infrequently.</label>
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q5" value="d" class="mr-2"> Never, a `lock` is always faster.</label>
                                </div>
                            </div>
                             <div>
                                <p class="font-semibold text-stone-800">6. Which of the following collection types is specifically designed to be thread-safe for concurrent operations?</p>
                                <div class="mt-2 space-y-2">
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q6" value="a" class="mr-2"> `List<T>`</label>
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q6" value="b" class="mr-2"> `ConcurrentDictionary<TKey, TValue>`</label>
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q6" value="c" class="mr-2"> `Dictionary<TKey, TValue>`</label>
                                    <label class="quiz-option block p-3 border border-stone-200 rounded-md cursor-pointer hover:bg-stone-50"><input type="radio" name="q6" value="d" class="mr-2"> `ArrayList`</label>
                                </div>
                            </div>

                            <div class="flex items-center gap-4 pt-4">
                                <button type="submit" class="bg-teal-600 text-white px-6 py-2 rounded-md hover:bg-teal-700 transition">Submit Answers</button>
                                <p id="quizResult" class="font-bold"></p>
                            </div>
                        </form>
                    </section>
                    
                    <section id="challenge" class="scroll-mt-20">
                        <h2 class="text-3xl font-bold text-stone-800 border-b-2 border-teal-500 pb-2 mb-6">🚀 Self-Assessment Challenge</h2>
                        <div class="bg-white p-6 rounded-lg shadow-sm">
                            <h3 class="text-xl font-semibold text-stone-700">The Dining Philosophers Problem</h3>
                            <p class="text-stone-600 my-2">Five philosophers sit at a round table. Between each pair of philosophers is one fork. A philosopher can only eat if they have both their left and right forks. The challenge is to design a system where no philosopher starves (deadlock) and they can all eventually eat.</p>
                            <details class="mt-4">
                                <summary class="cursor-pointer text-teal-600 font-semibold">Click to Reveal Detailed Solution</summary>
                                <div class="code-block mt-2">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-stone-800 text-white p-4 rounded-md text-sm"><code class="language-csharp">public class DiningPhilosophers
{
    private readonly object[] _forks = new object[5];
    public DiningPhilosophers() { for (int i = 0; i < 5; i++) _forks[i] = new object(); }

    public void StartDinner()
    {
        var philosophers = new Thread[5];
        for (int i = 0; i < 5; i++)
        {
            int id = i;
            philosophers[i] = new Thread(() => Dine(id));
            philosophers[i].Start();
        }
        foreach (var p in philosophers) p.Join();
    }

    private void Dine(int id)
    {
        int leftFork = id;
        int rightFork = (id + 1) % 5;

        // *** Deadlock Avoidance: Enforce lock acquisition order. ***
        // The last philosopher picks up right fork first, breaking the cycle.
        object firstLock = id == 4 ? _forks[rightFork] : _forks[leftFork];
        object secondLock = id == 4 ? _forks[leftFork] : _forks[rightFork];

        lock (firstLock)
        {
            Console.WriteLine($"P{id} picked up first fork.");
            lock (secondLock)
            {
                Console.WriteLine($"\tP{id} is eating.");
                Thread.Sleep(100);
            }
        }
    }
}
</code></pre>
                                </div>
                            </details>
                        </div>
                    </section>

                </main>

                <!-- Sticky Table of Contents -->
                <aside class="w-full lg:w-1/4 lg:sticky lg:top-20 h-full">
                    <div class="bg-white p-4 rounded-lg shadow-sm">
                        <h3 class="font-bold text-lg mb-4 text-stone-800">On This Page</h3>
                        <nav>
                            <ul class="space-y-2">
                                <li><a href="#introduction" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Introduction</a></li>
                                <li><a href="#core" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Core Concepts</a></li>
                                <li><a href="#hazards" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Concurrency Hazards</a></li>
                                <li><a href="#sync" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Synchronization Primitives</a></li>
                                <li><a href="#advanced" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Advanced Topics</a></li>
                                <li><a href="#coding" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Coding Practice</a></li>
                                <li><a href="#design" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">System Design</a></li>
                                <li><a href="#quiz" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Knowledge Check</a></li>
                                <li><a href="#challenge" class="toc-link block border-l-4 border-transparent p-2 text-stone-600 hover:text-teal-600">Self-Assessment</a></li>
                            </ul>
                        </nav>
                    </div>
                </aside>
            </div>
        </div>
    </div>

    <!-- Consistent Footer -->
    <footer class="bg-stone-800 text-white text-center p-4 mt-12">
        <p>&copy; 2025 C# Learning Module. All Rights Reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const sections = document.querySelectorAll('section[id]');
            const tocLinks = document.querySelectorAll('.toc-link');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.id;
                        tocLinks.forEach(link => {
                            link.classList.toggle('active', link.getAttribute('href') === `#${id}`);
                        });
                    }
                });
            }, { rootMargin: '-20% 0px -70% 0px' });
            sections.forEach(section => observer.observe(section));
            
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', () => {
                    const code = button.closest('.code-block').querySelector('code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                    });
                });
            });

            const ctx = document.getElementById('perfSafetyChart').getContext('2d');
            const perfSafetyChart = new Chart(ctx, {
                type: 'bar', data: { labels: ['Performance', 'Thread Safety'], datasets: [{ label: 'Level', data: [90, 20], backgroundColor: ['rgba(20, 184, 166, 0.6)', 'rgba(249, 115, 22, 0.6)'], borderColor: ['rgba(13, 148, 136, 1)', 'rgba(234, 88, 12, 1)'], borderWidth: 1 }] },
                options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: 110 } }, plugins: { legend: { display: false }, title: { display: true, text: 'Performance vs. Thread Safety' } } }
            });
            document.getElementById('syncLevel').addEventListener('input', (e) => {
                const safety = parseInt(e.target.value);
                const performance = 110 - safety;
                perfSafetyChart.data.datasets[0].data = [performance, safety];
                perfSafetyChart.update();
            });

            const runRaceSimButton = document.getElementById('runRaceSimButton');
            const raceOutput = document.getElementById('raceOutput');
            runRaceSimButton.addEventListener('click', () => {
                raceOutput.innerHTML = '';
                runRaceSimButton.disabled = true;
                let counter = 0;
                const thread1 = () => {
                    for(let i=0; i<10; i++) {
                        setTimeout(() => {
                           let current = counter;
                           raceOutput.innerHTML += `T1 reads ${current}<br>`;
                           setTimeout(() => {
                               counter = current + 1;
                               raceOutput.innerHTML += `T1 writes ${counter}<br>`;
                               raceOutput.scrollTop = raceOutput.scrollHeight;
                           }, Math.random() * 20);
                        }, Math.random() * 200);
                    }
                };
                 const thread2 = () => {
                    for(let i=0; i<10; i++) {
                         setTimeout(() => {
                           let current = counter;
                           raceOutput.innerHTML += `<span class="text-teal-600">T2 reads ${current}</span><br>`;
                           setTimeout(() => {
                               counter = current + 1;
                               raceOutput.innerHTML += `<span class="text-teal-600">T2 writes ${counter}</span><br>`;
                               raceOutput.scrollTop = raceOutput.scrollHeight;
                           }, Math.random() * 20);
                        }, Math.random() * 200);
                    }
                };
                thread1();
                thread2();
                setTimeout(() => {
                     raceOutput.innerHTML += `<b>Final Result: ${counter}</b> (Expected: 20)<br>`;
                     runRaceSimButton.disabled = false;
                }, 1000);
            });
            
            const quizForm = document.getElementById('quizForm');
            const quizResult = document.getElementById('quizResult');
            const correctAnswers = { q1: 'b', q2: 'c', q3: 'b', q4: 'c', q5: 'c', q6: 'b' };

            quizForm.addEventListener('submit', e => {
                e.preventDefault();
                let score = 0;
                const totalQuestions = Object.keys(correctAnswers).length;
                const formData = new FormData(quizForm);

                document.querySelectorAll('.quiz-option').forEach(el => el.classList.remove('correct', 'incorrect'));
                
                for(const [question, userAnswer] of formData.entries()) {
                    const label = quizForm.querySelector(`input[name="${question}"][value="${userAnswer}"]`).parentElement;
                    if (userAnswer === correctAnswers[question]) {
                        score++;
                        label.classList.add('correct');
                    } else {
                        label.classList.add('incorrect');
                    }
                }
                
                Object.entries(correctAnswers).forEach(([q, a]) => {
                    const correctLabel = quizForm.querySelector(`input[name="${q}"][value="${a}"]`).parentElement;
                    if(!correctLabel.classList.contains('correct')) {
                        correctLabel.classList.add('correct');
                    }
                });

                quizResult.textContent = `You scored ${score} out of ${totalQuestions}!`;
            });
        });
    </script>
</body>
</html>

