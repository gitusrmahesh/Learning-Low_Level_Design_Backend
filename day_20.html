<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 20: .NET Source Generators</title>
    <!-- Chosen Palette: Slate & Amber -->
    <!-- Application Structure Plan: A single-page, linear lesson format is chosen for optimal learning flow. A sticky table of contents on the right provides easy navigation through the sequential sections: Theory, UML Diagram, Coding Practices (by difficulty), Case Study, and Assessments. This structure supports both cover-to-cover learning and quick reference to specific topics, which is ideal for a complex technical subject. Interactions like the step-by-step diagram reveal, quiz feedback, and code copying are designed to keep the user engaged and actively learning. -->
    <!-- Visualization & Content Choices: Report Info: UML Compile-time flow. Goal: Organize/Explain Process. Viz/Method: Interactive diagram built with HTML/CSS/JS. Interaction: Elements fade in sequentially on button click to explain the compilation steps. Justification: This actively engages the user, breaking down a complex process into digestible steps, superior to a static image. Library: Vanilla JS. Report Info: Coding examples. Goal: Inform/Demonstrate. Method: Syntax-highlighted code blocks. Interaction: Copy-to-clipboard button. Justification: Eases practical application for the developer. Library: Vanilla JS. No quantitative data was present in the source material, so Chart.js was not used. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700;800&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }
        .font-lexend {
            font-family: 'Lexend', sans-serif;
        }
        .toc-link.active {
            color: #c2410c;
            border-left-color: #c2410c;
            font-weight: 600;
        }
        .code-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            background-color: #334155;
            color: #e2e8f0;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #475569;
        }
        .quiz-option.correct {
            background-color: #dcfce7;
            border-color: #22c55e;
        }
        .quiz-option.incorrect {
            background-color: #fee2e2;
            border-color: #ef4444;
        }
        .highlight {
             background: linear-gradient(120deg, #fef3c7 0%, #fde68a 100%);
             padding: 2px 5px;
             border-radius: 3px;
        }
        .diagram-arrow {
            position: relative;
            height: 2px;
            background-color: #64748b;
            margin: 2rem 0;
        }
        .diagram-arrow::after {
            content: '▶';
            position: absolute;
            right: -8px;
            top: -9px;
            color: #64748b;
        }
        .diagram-step {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .diagram-step.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="bg-slate-100/80 border-b border-slate-200">
            <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8 relative">
                <header class="text-center">
                    <h1 class="text-4xl sm:text-5xl font-extrabold text-slate-800 mt-1 tracking-tight font-lexend">Low-Level Design Bootcamp</h1>
                    <p class="mt-3 text-slate-600 max-w-xl mx-auto">Your 60-Day Interactive Roadmap to Mastering Backend Engineering.</p>
                </header>
                <a href="roadmap.html?week=3" class="absolute top-1/2 -translate-y-1/2 right-4 sm:right-6 lg:right-8 bg-slate-200 text-slate-700 text-sm font-semibold py-2 px-4 rounded-lg hover:bg-slate-300 transition-colors shadow-sm">
                    Return to Homepage
                </a>
            </div>
        </div>

        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
            <div class="lg:grid lg:grid-cols-12 lg:gap-8">
                <main class="lg:col-span-9">
                    <div class="space-y-16">
                        
                        <section id="introduction">
                            <div class="flex items-center mb-4">
                                <span class="text-6xl font-black text-slate-200 mr-4">20</span>
                                <div>
                                    <h2 class="text-3xl font-bold font-lexend text-slate-800">Source Generators</h2>
                                    <p class="text-slate-500">Automating boilerplate and optimizing code at compile time.</p>
                                </div>
                            </div>
                            <p class="text-lg text-slate-600 leading-relaxed">
                                Welcome to Day 20. Today, we're diving into one of the most powerful features of the modern .NET ecosystem: Source Generators. Imagine having a tireless assistant that writes repetitive, boilerplate code for you, ensuring it's always correct, up-to-date, and performant. That's the magic of Source Generators. They plug directly into the C# compiler (Roslyn) to inspect your code and generate new C# source files on the fly during compilation. This isn't reflection; it's a compile-time mechanism that eliminates runtime overhead while dramatically improving developer productivity.
                            </p>
                        </section>

                        <section id="theory">
                            <h3 class="text-2xl font-bold font-lexend text-slate-800 border-l-4 border-amber-500 pl-4 mb-6">Theory Topics</h3>
                            
                            <div class="space-y-12">
                                <div>
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">1. What are Source Generators? (A Deeper Look)</h4>
                                    <p class="text-slate-600 mb-4">
                                        At its core, a Source Generator is a .NET assembly, loaded by the Roslyn compiler, that leverages the compiler's own APIs to analyze source code and emit new source files during the compilation process. It's a form of <span class="highlight font-semibold">compile-time metaprogramming</span>. Unlike other techniques, it doesn't modify existing code; it only adds to it.
                                    </p>
                                    <ol class="list-decimal list-inside space-y-2 text-slate-600 mb-4 pl-4">
                                        <li><strong class="text-slate-700">Inspect User Code:</strong> Using the Roslyn Analyzer APIs, a generator receives a `Compilation` object. This is a rich, immutable representation of everything the compiler knows about the user's code—syntax, symbols, types, references, and more.</li>
                                        <li><strong class="text-slate-700">Generate New Code:</strong> Based on its analysis, the generator constructs C# code as simple strings. These strings are then provided back to the compiler with a "hint name" (e.g., `MyClass.g.cs`).</li>
                                        <li><strong class="text-slate-700">Integrate Seamlessly:</strong> The compiler treats these new source files as if they were written by the developer and includes them in the final assembly. The IDE is also aware of them, providing IntelliSense for generated types and methods.</li>
                                    </ol>
                                    <div class="bg-amber-100 border-l-4 border-amber-400 text-amber-800 p-4 rounded-r-lg">
                                        <p><strong class="font-semibold">Analogy: The Compiler's Assistant.</strong> Think of the compiler as a master architect building your application. A Source Generator is like a specialized assistant that the architect consults. The architect says, "I'm building a class `User`, and it has these properties." The assistant quickly drafts up a `ToString()` method, a mapper, or some logging extensions for that `User` class and hands the blueprints (source files) back to the architect, who includes them in the final build. The assistant never changes the architect's original plans, but it adds perfectly complementary new ones.
                                        </p>
                                    </div>
                                </div>

                                <div>
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">2. The Problem They Solve: The Evolution of Metaprogramming</h4>
                                    <p class="text-slate-600 mb-4">Source Generators were created to overcome the limitations of previous metaprogramming techniques in .NET.</p>
                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                        <div class="bg-white p-4 border border-rose-200 rounded-lg">
                                            <h5 class="font-semibold text-rose-600">Problem: Runtime Reflection</h5>
                                            <p class="text-sm text-slate-600 mt-1">Slow, especially at startup. Lacks compile-time safety (e.g., `Type.GetProperty("Naem")` compiles but fails at runtime). Incompatible with Ahead-of-Time (AOT) compilation which strips unused code.</p>
                                        </div>
                                        <div class="bg-white p-4 border border-orange-200 rounded-lg">
                                            <h5 class="font-semibold text-orange-600">Problem: T4 Templates</h5>
                                            <p class="text-sm text-slate-600 mt-1">Run as a separate step before the build. They don't have access to the rich semantic information of the compiler, making them "dumb" text generators that can't easily inspect your code's meaning.</p>
                                        </div>
                                        <div class="bg-white p-4 border border-sky-200 rounded-lg">
                                            <h5 class="font-semibold text-sky-600">Problem: IL Weaving (Fody)</h5>
                                            <p class="text-sm text-slate-600 mt-1">Very powerful, as it modifies compiled Intermediate Language. However, it's complex, can feel like "magic," is difficult to debug, and can be brittle across different .NET versions.</p>
                                        </div>
                                    </div>
                                    <div class="mt-4 p-4 bg-emerald-100 border-l-4 border-emerald-400 text-emerald-800 rounded-r-lg">
                                      <p><strong class="font-semibold">The Source Generator Solution:</strong> By integrating directly into the compiler, source generators get the best of all worlds: deep, semantic understanding of code, compile-time safety, high performance (no runtime cost), and full AOT compatibility. They are the official, supported way to do compile-time metaprogramming.</p>
                                    </div>
                                </div>

                                <div>
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">3. How They Work: Syntax Trees and Semantic Models</h4>
                                    <p class="text-slate-600 mb-4">To understand a generator, you must understand the two key components of the Roslyn compiler it interacts with:</p>
                                    <div class="space-y-6">
                                        <div>
                                            <h5 class="font-semibold text-slate-700">The Syntax Tree (AST)</h5>
                                            <p class="text-slate-600 mb-2">The compiler first parses your code text into a tree-like data structure called a Syntax Tree or Abstract Syntax Tree (AST). It represents the <span class="highlight">syntactical structure</span> of your code—classes, methods, statements, etc.—but knows nothing about types or what variables refer to. It's just the grammatical structure.</p>
                                            <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                                <button class="copy-button">Copy</button>
                                                <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-gray-400">// This snippet shows how a generator might find all class declarations.</span>
<span class="text-sky-400">foreach</span> (<span class="text-green-400">SyntaxTree</span> tree <span class="text-sky-400">in</span> context.Compilation.SyntaxTrees)
{
    <span class="text-green-400">var</span> root = tree.GetRoot();
    <span class="text-green-400">var</span> classes = root.DescendantNodes().OfType<<span class="text-green-400">ClassDeclarationSyntax</span>>>();
    <span class="text-sky-400">foreach</span>(<span class="text-green-400">var</span> classSyntax <span class="text-sky-400">in</span> classes)
    {
        <span class="text-gray-400">// We have found a class, but we don't know its full type name yet.</span>
    }
}
</code></pre>
                                            </div>
                                        </div>
                                        <div>
                                            <h5 class="font-semibold text-slate-700">The Semantic Model</h5>
                                            <p class="text-slate-600 mb-2">After creating Syntax Trees, the compiler performs binding and creates a Semantic Model for each tree. This model enriches the syntax tree with the <span class="highlight">semantic meaning</span> of the code. It answers questions like: "What is the full .NET type of this variable?", "Which method overload is being called here?", "Is this type a `struct` or a `class`?". This is what makes generators so powerful.</p>
                                            <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                                <button class="copy-button">Copy</button>
                                                <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-gray-400">// Continuing from above, we get the semantic model to learn more.</span>
<span class="text-green-400">SemanticModel</span> semanticModel = context.Compilation.GetSemanticModel(tree);
<span class="text-sky-400">foreach</span>(<span class="text-green-400">var</span> classSyntax <span class="text-sky-400">in</span> classes)
{
    <span class="text-gray-400">// Get the "symbol" for the class, which contains all semantic info.</span>
    <span class="text-green-400">INamedTypeSymbol</span> classSymbol = semanticModel.GetDeclaredSymbol(classSyntax);
    
    <span class="text-gray-400">// Now we can ask meaningful questions!</span>
    <span class="text-sky-400">string</span> fullTypeName = classSymbol.ToDisplayString();
    <span class="text-sky-400">bool</span> isStatic = classSymbol.IsStatic;
    <span class="text-green-400">var</span> allMembers = classSymbol.GetMembers();
}
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div>
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">4. Generator APIs: `ISourceGenerator` vs. `IIncrementalGenerator`</h4>
                                    <p class="text-slate-600 mb-4">There are two ways to implement a source generator. The modern `IIncrementalGenerator` is strongly preferred for performance.</p>
                                    <div class="bg-white p-6 rounded-lg border border-slate-200">
                                        <h5 class="text-lg font-semibold text-slate-700">`ISourceGenerator` (The V1 API)</h5>
                                        <p class="text-slate-600 mt-2 mb-4">This was the original API. Its `Execute` method is called for <span class="highlight">every single compilation</span>. Inside an IDE like Visual Studio, this means it re-runs on almost every keystroke. For complex analysis, this can cause significant UI lag. It has no built-in way to cache work between edits.</p>
                                        
                                        <h5 class="text-lg font-semibold text-slate-700 mt-6">`IIncrementalGenerator` (The V2 API - Recommended)</h5>
                                        <p class="text-slate-600 mt-2 mb-4">This newer API was designed for performance. Instead of one `Execute` method, you define a <span class="highlight">pipeline of data transformations</span>. The compiler manages this pipeline and intelligently caches the output of each step. If a user's code edit doesn't affect the input to a particular step, that step (and all subsequent steps) can use their cached results instead of re-running. This makes IDE integration incredibly fast and efficient.</p>
                                        <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                            <button class="copy-button">Copy</button>
                                            <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp">[<span class="text-green-400">Generator</span>]
<span class="text-sky-400">public class</span> <span class="text-yellow-300">MyIncrementalGenerator</span> : <span class="text-green-400">IIncrementalGenerator</span>
{
    <span class="text-sky-400">public void</span> <span class="text-yellow-300">Initialize</span>(<span class="text-green-400">IncrementalGeneratorInitializationContext</span> context)
    {
        <span class="text-gray-400">// 1. Create a provider that finds all classes with our target attribute.
        // This step is cached. It only re-runs if class/attribute syntax changes.</span>
        <span class="text-green-400">IncrementalValuesProvider</span><ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                <span class="text-orange-400">"MyLibrary.MyAttribute"</span>,
                predicate: (node, _) => node <span class="text-sky-400">is</span> <span class="text-green-400">ClassDeclarationSyntax</span>,
                transform: (ctx, _) => (<span class="text-green-400">ClassDeclarationSyntax</span>)ctx.TargetNode);

        <span class="text-gray-400">// 2. Combine the syntax with the compilation to get semantic symbols.
        // This step is also cached.</span>
        <span class="text-green-400">var</span> combined = classDeclarations.Combine(context.CompilationProvider);

        <span class="text-gray-400">// 3. Register the final output step. This is where source code is emitted.</span>
        context.RegisterSourceOutput(combined, (spc, source) =>
        {
            <span class="text-gray-400">// The 'source' tuple contains the class syntax and compilation.
            // ... Logic to get symbol and generate code string ...</span>
            spc.AddSource(<span class="text-orange-400">"GeneratedFile.g.cs"</span>, generatedCode);
        });
    }
}
</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="uml">
                            <h3 class="text-2xl font-bold font-lexend text-slate-800 border-l-4 border-amber-500 pl-4 mb-6">UML Task: Compile-Time Flow Diagram</h3>
                            <p class="text-slate-600 mb-6">This interactive diagram illustrates where Source Generators fit into the Roslyn compilation process. Click the button to see the steps unfold.</p>
                            
                            <div class="bg-white p-6 border border-slate-200 rounded-lg">
                                <div id="diagram-container" class="flex flex-col items-center text-center">
                                    <div class="diagram-step w-full" data-step="1">
                                        <div class="p-4 bg-slate-100 rounded-lg shadow-sm border border-slate-200">
                                            <p class="font-semibold text-slate-800">1. User Code & Generator Code</p>
                                            <p class="text-sm text-slate-500">Your handwritten C# files and the Source Generator's project code.</p>
                                        </div>
                                    </div>
                                    <div class="diagram-step w-1/2" data-step="2">
                                        <div class="diagram-arrow"></div>
                                    </div>
                                    <div class="diagram-step w-full" data-step="3">
                                        <div class="p-4 bg-sky-100 rounded-lg shadow-sm border border-sky-200">
                                            <p class="font-semibold text-sky-800">2. Roslyn Compiler Starts</p>
                                            <p class="text-sm text-sky-500">The compiler (csc.exe) begins the build process.</p>
                                        </div>
                                    </div>
                                    <div class="diagram-step w-1/2" data-step="4">
                                        <div class="diagram-arrow"></div>
                                    </div>
                                     <div class="diagram-step w-full" data-step="5">
                                        <div class="p-4 bg-amber-100 rounded-lg shadow-sm border border-amber-200">
                                            <p class="font-semibold text-amber-800">3. Source Generator Executes</p>
                                            <p class="text-sm text-amber-500">The generator's `Initialize` and `Execute` methods run. It inspects the initial compilation.</p>
                                        </div>
                                    </div>
                                     <div class="diagram-step w-1/2" data-step="6">
                                        <div class="diagram-arrow"></div>
                                    </div>
                                    <div class="diagram-step w-full" data-step="7">
                                        <div class="p-4 bg-indigo-100 rounded-lg shadow-sm border border-indigo-200">
                                            <p class="font-semibold text-indigo-800">4. New Source Files Added</p>
                                            <p class="text-sm text-indigo-500">The generator uses `context.AddSource()` to add new C# code strings to the compilation.</p>
                                        </div>
                                    </div>
                                    <div class="diagram-step w-1/2" data-step="8">
                                        <div class="diagram-arrow"></div>
                                    </div>
                                    <div class="diagram-step w-full" data-step="9">
                                        <div class="p-4 bg-emerald-100 rounded-lg shadow-sm border border-emerald-200">
                                            <p class="font-semibold text-emerald-800">5. Final Compilation</p>
                                            <p class="text-sm text-emerald-500">Roslyn compiles BOTH the original user code and the newly generated code into the final assembly (DLL/EXE).</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="text-center mt-6">
                                    <button id="diagram-trigger" class="bg-slate-700 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-800 transition-colors shadow-sm">
                                        Animate Flow
                                    </button>
                                </div>
                            </div>
                        </section>

                        <section id="coding-practice">
                            <h3 class="text-2xl font-bold font-lexend text-slate-800 border-l-4 border-amber-500 pl-4 mb-6">Coding Practice</h3>
                            <div class="space-y-12">
                                <div class="bg-white p-6 border border-slate-200 rounded-lg">
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">[Intro] Hello World Source Generator</h4>
                                    <p class="text-slate-600 mb-4">The simplest possible generator. It doesn't inspect any code; it just adds a new, static C# class to the compilation.</p>
                                    <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                        <button class="copy-button">Copy</button>
                                        <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-sky-400">using</span> Microsoft.CodeAnalysis;

<span class="text-gray-400">// Project: MyGenerators.csproj - targets netstandard2.0 and references Microsoft.CodeAnalysis.CSharp</span>

[<span class="text-green-400">Generator</span>]
<span class="text-sky-400">public class</span> <span class="text-yellow-300">HelloWorldGenerator</span> : <span class="text-green-400">ISourceGenerator</span>
{
    <span class="text-sky-400">public void</span> <span class="text-yellow-300">Initialize</span>(<span class="text-green-400">GeneratorInitializationContext</span> context) { }

    <span class="text-sky-400">public void</span> <span class="text-yellow-300">Execute</span>(<span class="text-green-400">GeneratorExecutionContext</span> context)
    {
        <span class="text-sky-400">const string</span> source = <span class="text-orange-400">@"
namespace HelloWorldGenerated
{
    public static class Greeter
    {
        public static void SayHello()
        {
            System.Console.WriteLine(""Hello from a generated world!"");
        }
    }
}"</span>;

        context.AddSource(<span class="text-orange-400">"HelloWorld.g.cs"</span>, source);
    }
}

<span class="text-gray-400">// In your main application (referencing the generator project):
// HelloWorldGenerated.Greeter.SayHello(); // This line will compile and run successfully.</span>
</code></pre>
                                    </div>
                                </div>

                                <div class="bg-white p-6 border border-slate-200 rounded-lg">
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">[Easy] Auto Property Notifier Generator</h4>
                                    <p class="text-slate-600 mb-4">A generator that finds classes implementing `INotifyPropertyChanged` and auto-generates the backing fields and property implementations for fields marked with an attribute. This is a classic example of reducing boilerplate.</p>
                                    <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                        <button class="copy-button">Copy</button>
                                        <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-gray-400">// 1. Define an attribute for the generator to find.</span>
[<span class="text-green-400">AttributeUsage</span>(<span class="text-green-400">AttributeTargets</span>.Field)]
<span class="text-sky-400">public class</span> <span class="text-yellow-300">AutoNotifyAttribute</span> : <span class="text-green-400">Attribute</span> { }

<span class="text-gray-400">// 2. The user's code.</span>
<span class="text-sky-400">public partial class</span> <span class="text-yellow-300">MyViewModel</span> : <span class="text-green-400">INotifyPropertyChanged</span>
{
    [<span class="text-green-400">AutoNotify</span>]
    <span class="text-sky-400">private string</span> _name;

    <span class="text-sky-400">public event</span> <span class="text-green-400">PropertyChangedEventHandler</span> PropertyChanged;
}

<span class="text-gray-400">// 3. The Generator's Execute method (simplified).</span>
<span class="text-sky-400">public void</span> <span class="text-yellow-300">Execute</span>(<span class="text-green-400">GeneratorExecutionContext</span> context)
{
    <span class="text-gray-400">// Logic to find all fields with [AutoNotify] attribute...
    // For each field found (e.g., _name):</span>
    
    <span class="text-sky-400">string</span> propertyName = <span class="text-orange-400">"Name"</span>; <span class="text-gray-400">// derive from field name "_name"</span>
    <span class="text-sky-400">string</span> fieldName = <span class="text-orange-400">"_name"</span>;
    <span class="text-sky-400">string</span> className = <span class="text-orange-400">"MyViewModel"</span>;

    <span class="text-sky-400">string</span> source = <span class="text-orange-400">$@"
public partial class {className}
{{
    public string {propertyName}
    {{
        get => this.{fieldName};
        set
        {{
            this.{fieldName} = value;
            this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof({propertyName})));
        }}
    }}
}}"</span>;

    context.AddSource(<span class="text-orange-400">$"{className}.{propertyName}.g.cs"</span>, source);
}
</code></pre>
                                    </div>
                                </div>
                                
                                <div class="bg-white p-6 border border-slate-200 rounded-lg">
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">[Medium] Logging Method Generator</h4>
                                    <p class="text-slate-600 mb-4">Creates high-performance logging methods using the `Microsoft.Extensions.Logging.LoggerMessage.Define` pattern. The generator finds methods marked with a `[Log]` attribute and generates the optimized logging delegate for it.</p>
                                    <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                        <button class="copy-button">Copy</button>
                                        <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-gray-400">// 1. User's code. Notice the partial class and method.</span>
<span class="text-sky-400">public partial class</span> <span class="text-yellow-300">MyService</span>
{
    <span class="text-sky-400">private readonly</span> <span class="text-green-400">ILogger</span> _logger;
    
    <span class="text-sky-400">public</span> <span class="text-yellow-300">MyService</span>(<span class="text-green-400">ILogger</span><MyService> logger) => _logger = logger;
    
    [<span class="text-green-400">Log</span>(<span class="text-green-400">LogLevel</span>.Information, <span class="text-orange-400">"User {UserId} logged in at {LoginTime}"</span>)]
    <span class="text-sky-400">public partial void</span> <span class="text-yellow-300">LogUserLogin</span>(<span class="text-sky-400">string</span> userId, <span class="text-green-400">DateTime</span> loginTime);
}

<span class="text-gray-400">// 2. Generated code.</span>
<span class="text-sky-400">public partial class</span> <span class="text-yellow-300">MyService</span>
{
    <span class="text-sky-400">private static readonly</span> <span class="text-green-400">Action</span><ILogger, <span class="text-sky-400">string</span>, <span class="text-green-400">DateTime</span>, <span class="text-green-400">Exception</span>> _logUserLogin = 
        <span class="text-green-400">LoggerMessage</span>.Define<<span class="text-sky-400">string</span>, <span class="text-green-400">DateTime</span>>(
            <span class="text-green-400">LogLevel</span>.Information,
            <span class="text-sky-400">new</span> <span class="text-green-400">EventId</span>(1, nameof(LogUserLogin)),
            <span class="text-orange-400">"User {UserId} logged in at {LoginTime}"</span>);

    <span class="text-sky-400">public partial void</span> <span class="text-yellow-300">LogUserLogin</span>(<span class="text-sky-400">string</span> userId, <span class="text-green-400">DateTime</span> loginTime)
    {
        _logUserLogin(_logger, userId, loginTime, <span class="text-sky-400">null</span>);
    }
}
</code></pre>
                                    </div>
                                </div>

                                <div class="bg-white p-6 border border-slate-200 rounded-lg">
                                    <h4 class="text-xl font-semibold text-slate-700 mb-2">[Hard] DTO → Entity Generator</h4>
                                    <p class="text-slate-600 mb-4">A more complex generator that creates mapping extension methods. It finds classes marked with a `[MapTo(typeof(Entity))]` attribute and generates a `ToEntity()` method that copies properties with matching names and types.</p>
                                     <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                        <button class="copy-button">Copy</button>
                                        <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-gray-400">// 1. User's code.</span>
<span class="text-sky-400">public class</span> <span class="text-yellow-300">User</span> { <span class="text-sky-400">public int</span> Id { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; } <span class="text-sky-400">public string</span> Name { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; } }

[<span class="text-green-400">MapTo</span>(<span class="text-sky-400">typeof</span>(<span class="text-green-400">User</span>))]
<span class="text-sky-400">public partial class</span> <span class="text-yellow-300">CreateUserDto</span>
{
    <span class="text-sky-400">public string</span> Name { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }
}

<span class="text-gray-400">// 2. Generated Code. The generator inspects both types and finds matching properties.</span>
<span class="text-sky-400">public static class</span> <span class="text-yellow-300">CreateUserDtoMappings</span>
{
    <span class="text-sky-400">public static</span> <span class="text-green-400">User</span> <span class="text-yellow-300">ToUser</span>(<span class="text-sky-400">this</span> <span class="text-green-400">CreateUserDto</span> dto)
    {
        <span class="text-sky-400">return new</span> <span class="text-green-400">User</span>
        {
            <span class="text-gray-400">// The generator found that 'Name' exists on both types.</span>
            Name = dto.Name,
            <span class="text-gray-400">// The generator saw that 'Id' does not exist on the DTO, so it is not mapped.</span>
        };
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="case-study">
                            <h3 class="text-2xl font-bold font-lexend text-slate-800 border-l-4 border-amber-500 pl-4 mb-6">Case Study: Auto DTO Class Generator</h3>
                            <p class="text-slate-600 mb-4">
                                Let's flip the previous example. Instead of mapping from a DTO, what if we could generate the DTO itself directly from an Entity? This is a common requirement in API development where you want to expose a subset of an entity's properties.
                            </p>
                            <div class="bg-white p-6 border border-slate-200 rounded-lg space-y-4">
                                <div>
                                    <h4 class="font-semibold text-slate-700">The Problem</h4>
                                    <p class="text-slate-600">You have a database entity, `Product`, with many properties (`Id`, `Name`, `Description`, `Price`, `InternalStockCode`, `LastUpdated`). For a public API, you only want to expose `Id`, `Name`, and `Price`. Manually creating and maintaining a `ProductDto` class is tedious and error-prone. If you add a new public-facing property to `Product`, you have to remember to add it to the DTO.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-slate-700">The Source Generator Solution</h4>
                                    <p class="text-slate-600">We can create a generator that works with attributes on the entity itself.</p>
                                </div>
                                <div class="code-block bg-slate-800 rounded-lg overflow-hidden">
                                    <button class="copy-button">Copy</button>
                                    <pre class="p-4 text-sm text-white overflow-x-auto"><code class="language-csharp"><span class="text-gray-400">// 1. User's Entity with attributes defining a DTO.</span>
[<span class="text-green-400">GenerateDto</span>(<span class="text-orange-400">"ProductDto"</span>)]
<span class="text-sky-400">public class</span> <span class="text-yellow-300">Product</span>
{
    [<span class="text-green-400">DtoProperty</span>]
    <span class="text-sky-400">public int</span> Id { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }

    [<span class="text-green-400">DtoProperty</span>]
    <span class="text-sky-400">public string</span> Name { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }

    <span class="text-sky-400">public string</span> Description { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; } <span class="text-gray-400">// Not marked, so it won't be in the DTO</span>

    [<span class="text-green-400">DtoProperty</span>]
    <span class="text-sky-400">public decimal</span> Price { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }

    <span class="text-sky-400">public string</span> InternalStockCode { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }
    <span class="text-sky-400">public</span> <span class="text-green-400">DateTime</span> LastUpdated { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }
}

<span class="text-gray-400">// 2. The code our generator creates.</span>
<span class="text-sky-400">public class</span> <span class="text-yellow-300">ProductDto</span>
{
    <span class="text-sky-400">public int</span> Id { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }
    <span class="text-sky-400">public string</span> Name { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }
    <span class="text-sky-400">public decimal</span> Price { <span class="text-sky-400">get</span>; <span class="text-sky-400">set</span>; }
}
</code></pre>
                                </div>
                                <div>
                                  <h4 class="font-semibold text-slate-700">Benefits</h4>
                                  <ul class="list-disc list-inside text-slate-600 space-y-1">
                                    <li><strong class="text-slate-700">Single Source of Truth:</strong> The entity becomes the single source of truth for what is public.</li>
                                    <li><strong class="text-slate-700">Maintainability:</strong> Adding a new public property is as simple as adding one `[DtoProperty]` attribute.</li>
                                    <li><strong class="text-slate-700">Compile-Time Safety:</strong> The DTO is always perfectly in sync with the entity's definition at compile time.</li>
                                  </ul>
                                </div>
                            </div>
                        </section>
                        
                        <section id="knowledge-check">
                            <h3 class="text-2xl font-bold font-lexend text-slate-800 border-l-4 border-amber-500 pl-4 mb-6">Knowledge Check Quiz</h3>
                            <div id="quiz-container" class="space-y-6"></div>
                        </section>

                        <section id="self-assessment">
                            <h3 class="text-2xl font-bold font-lexend text-slate-800 border-l-4 border-amber-500 pl-4 mb-6">Self-Assessment Challenge</h3>
                            <div class="bg-white p-6 border border-slate-200 rounded-lg">
                                <h4 class="text-lg font-semibold text-slate-800">The Challenge: A Builder Pattern Generator</h4>
                                <p class="text-slate-600 mt-2 mb-4">
                                    The Builder pattern is a creational design pattern that lets you construct complex objects step by step. It's often verbose to implement manually. Your task is to design a source generator that creates a fluent Builder for any class marked with a `[GenerateBuilder]` attribute.
                                </p>
                                <p class="text-slate-600 mb-4">
                                    For a class like `public class Pizza { public string Size { get; set; } public bool HasExtraCheese { get; set; } }`, the generator should create a `PizzaBuilder` class that allows for code like this:
                                </p>
                                <div class="bg-slate-100 p-3 rounded-md text-sm text-slate-700">
                                    <code>var pizza = new PizzaBuilder().WithSize("Large").WithExtraCheese(true).Build();</code>
                                </div>
                                <div class="mt-6">
                                    <button id="toggle-solution-btn" class="font-semibold text-amber-600 hover:text-amber-700">Show Solution & Explanation ▼</button>
                                    <div id="solution-content" class="hidden mt-4 border-t border-slate-200 pt-4">
                                        <h5 class="font-semibold text-slate-700">Solution Breakdown</h5>
                                        <p class="text-slate-600 mt-2 mb-4">A robust solution would involve these steps in the generator's `Execute` method:</p>
                                        <ol class="list-decimal list-inside space-y-2 text-slate-600">
                                            <li><strong>Syntax Receiver:</strong> Implement an `ISyntaxReceiver` to efficiently find all classes decorated with the `[GenerateBuilder]` attribute.</li>
                                            <li><strong>Symbol Analysis:</strong> In `Execute`, loop through the classes found by the receiver. For each class symbol, get its name and namespace.</li>
                                            <li><strong>Property Inspection:</strong> Iterate through the public, settable properties of the class symbol. For each property, get its name and type.</li>
                                            <li><strong>Source Generation (String Building):</strong>
                                                <ul class="list-disc list-inside ml-6 mt-2">
                                                    <li>Start building the builder class string: `public class {ClassName}Builder { ... }`.</li>
                                                    <li>For each property (e.g., `string Name`), generate a private backing field in the builder (`private string _name;`) and a fluent "With" method: `public {ClassName}Builder WithName(string name) { this._name = name; return this; }`.</li>
                                                    <li>Generate the final `Build()` method which creates a new instance of the target class and assigns all the properties from the builder's fields: `public {ClassName} Build() { return new {ClassName} { Name = this._name, ... }; }`.</li>
                                                </ul>
                                            </li>
                                            <li><strong>Add Source:</strong> Use `context.AddSource()` to add the fully constructed string for the builder class to the compilation.</li>
                                        </ol>
                                        <div class="mt-4 p-4 bg-sky-100 border-l-4 border-sky-400 text-sky-800 rounded-r-lg">
                                            <p><strong class="font-semibold">Key Consideration:</strong> This generator must handle various property types (strings, ints, bools, complex types) and correctly generate the method signatures and assignments for each.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>

                    </div>
                </main>

                <aside class="hidden lg:block lg:col-span-3">
                    <nav id="toc" class="sticky top-24">
                        <h4 class="font-semibold text-slate-800 mb-4">On this page</h4>
                        <ul class="space-y-2 text-slate-500 text-sm">
                            <li><a href="#introduction" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">Introduction</a></li>
                            <li><a href="#theory" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">Theory Topics</a></li>
                            <li><a href="#uml" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">UML: Flow Diagram</a></li>
                            <li><a href="#coding-practice" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">Coding Practice</a></li>
                            <li><a href="#case-study" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">Case Study</a></li>
                            <li><a href="#knowledge-check" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">Knowledge Check</a></li>
                            <li><a href="#self-assessment" class="toc-link block border-l-2 border-transparent pl-4 hover:text-slate-800 transition-colors">Self-Assessment</a></li>
                        </ul>
                    </nav>
                </aside>
            </div>
        </div>
        
        <footer class="text-center mt-16 py-8 border-t border-slate-200">
            <p class="text-slate-700 font-semibold">Low-Level Design Bootcamp</p>
            <p class="text-sm text-slate-500 mt-2">A personalized learning roadmap curated by Mr. Mahesh Singare.</p>
            <p class="text-xs text-slate-400 mt-4">&copy; 2025. All Rights Reserved.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Copy to Clipboard functionality ---
            const allCodeBlocks = document.querySelectorAll('.code-block');
            allCodeBlocks.forEach(block => {
                const button = block.querySelector('.copy-button');
                const code = block.querySelector('code').innerText;
                button.addEventListener('click', () => {
                    navigator.clipboard.writeText(code).then(() => {
                        button.innerText = 'Copied!';
                        setTimeout(() => {
                            button.innerText = 'Copy';
                        }, 2000);
                    });
                });
            });

            // --- Sticky TOC and Scrollspy ---
            const toc = document.getElementById('toc');
            const tocLinks = toc.querySelectorAll('.toc-link');
            const sections = Array.from(tocLinks).map(link => document.getElementById(link.getAttribute('href').substring(1)));

            const onScroll = () => {
                const scrollPosition = window.scrollY + 150;
                let activeSectionId = null;

                sections.forEach(section => {
                    if (section.offsetTop <= scrollPosition && section.offsetTop + section.offsetHeight > scrollPosition) {
                       activeSectionId = section.id;
                    }
                });
                
                tocLinks.forEach(link => {
                    if (link.getAttribute('href') === `#${activeSectionId}`) {
                        link.classList.add('active');
                    } else {
                        link.classList.remove('active');
                    }
                });
            };
            window.addEventListener('scroll', onScroll);
            onScroll(); // initial call

            // --- Interactive Diagram ---
            const diagramTrigger = document.getElementById('diagram-trigger');
            const diagramSteps = document.querySelectorAll('.diagram-step');
            let currentStep = 0;

            const resetDiagram = () => {
                diagramSteps.forEach(step => step.classList.remove('visible'));
                currentStep = 0;
            };

            const showNextStep = () => {
                if (currentStep < diagramSteps.length) {
                    const stepElem = diagramSteps[currentStep];
                     setTimeout(() => stepElem.classList.add('visible'), currentStep > 0 ? 100 : 0);
                    currentStep++;
                } else {
                    resetDiagram();
                }
            };
            
            diagramTrigger.addEventListener('click', () => {
                if (currentStep === 0) {
                    diagramTrigger.textContent = "Animating...";
                    for (let i = 0; i < diagramSteps.length; i++) {
                        setTimeout(showNextStep, i * 300);
                    }
                    setTimeout(() => {
                        diagramTrigger.textContent = "Reset Flow";
                    }, diagramSteps.length * 300);
                } else {
                    resetDiagram();
                    diagramTrigger.textContent = "Animate Flow";
                }
            });


            // --- Quiz Functionality ---
            const quizData = [
                {
                    question: "What is the primary purpose of a Source Generator?",
                    options: [
                        "To modify existing user code during compilation.",
                        "To generate new C# source files at compile-time.",
                        "To analyze code for performance issues at runtime.",
                        "To replace the need for unit tests."
                    ],
                    answer: "To generate new C# source files at compile-time."
                },
                {
                    question: "Which method of the `ISourceGenerator` interface is responsible for generating code?",
                    options: [
                        "Initialize()",
                        "Generate()",
                        "Execute()",
                        "AddSource()"
                    ],
                    answer: "Execute()"
                },
                {
                    question: "What is a major performance benefit of Source Generators over reflection?",
                    options: [
                        "They make the final executable smaller.",
                        "They eliminate runtime overhead by doing work at compile time.",
                        "They run on a separate thread during compilation.",
                        "They allow dynamic loading of assemblies."
                    ],
                    answer: "They eliminate runtime overhead by doing work at compile time."
                },
                {
                    question: "Can a Source Generator delete or change a method in your existing classes?",
                    options: [
                        "Yes, if you give it special permissions.",
                        "Only if the class is marked as partial.",
                        "No, Source Generators can only add new code, not modify existing code.",
                        "Yes, by directly manipulating the syntax tree."
                    ],
                    answer: "No, Source Generators can only add new code, not modify existing code."
                }
            ];

            const quizContainer = document.getElementById('quiz-container');

            quizData.forEach((q, index) => {
                const questionElem = document.createElement('div');
                questionElem.className = 'bg-white p-6 border border-slate-200 rounded-lg';

                const questionText = document.createElement('p');
                questionText.className = 'font-semibold text-slate-800 mb-4';
                questionText.textContent = `${index + 1}. ${q.question}`;
                questionElem.appendChild(questionText);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'space-y-3';
                questionElem.appendChild(optionsContainer);

                q.options.forEach(opt => {
                    const optionButton = document.createElement('button');
                    optionButton.className = 'quiz-option block w-full text-left p-3 border border-slate-300 rounded-lg hover:bg-slate-100 transition-colors';
                    optionButton.textContent = opt;

                    optionButton.addEventListener('click', () => {
                        const allOptions = optionsContainer.querySelectorAll('.quiz-option');
                        allOptions.forEach(btn => btn.disabled = true); // Disable all options after one is clicked

                        if (opt === q.answer) {
                            optionButton.classList.add('correct');
                        } else {
                            optionButton.classList.add('incorrect');
                            // Highlight the correct answer
                            allOptions.forEach(btn => {
                                if (btn.textContent === q.answer) {
                                    btn.classList.add('correct');
                                }
                            });
                        }
                    });

                    optionsContainer.appendChild(optionButton);
                });
                quizContainer.appendChild(questionElem);
            });


            // --- Self-Assessment Solution Toggle ---
            const toggleBtn = document.getElementById('toggle-solution-btn');
            const solutionContent = document.getElementById('solution-content');

            toggleBtn.addEventListener('click', () => {
                const isHidden = solutionContent.classList.contains('hidden');
                if (isHidden) {
                    solutionContent.classList.remove('hidden');
                    toggleBtn.textContent = 'Hide Solution & Explanation ▲';
                } else {
                    solutionContent.classList.add('hidden');
                    toggleBtn.textContent = 'Show Solution & Explanation ▼';
                }
            });

        });
    </script>
</body>
</html>

