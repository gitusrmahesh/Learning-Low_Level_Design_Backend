<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 54: Authorization (Role-Based & Policy-Based)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700;800&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
        }
        .font-lexend {
            font-family: 'Lexend', sans-serif;
        }
        .toc-link.active {
            color: #0ea5e9;
            font-weight: 600;
            border-left-color: #0ea5e9;
        }
        .code-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            padding: 0.25rem 0.6rem;
            font-size: 0.75rem;
            border-radius: 0.375rem;
            background-color: #475569;
            color: #f1f5f9;
            border: 1px solid #64748b;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #64748b;
        }
        .quiz-option.selected {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
        .quiz-option.correct {
            border-color: #22c55e;
            background-color: #dcfce7;
        }
        .quiz-option.incorrect {
            border-color: #ef4444;
            background-color: #fee2e2;
        }
        [x-cloak] { display: none !important; }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling;
            const code = codeBlock.querySelector('code');
            navigator.clipboard.writeText(code.innerText).then(() => {
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = 'Copy';
                }, 2000);
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const tocLinks = document.querySelectorAll('.toc-link');
            const sections = document.querySelectorAll('main section');
    
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    const id = entry.target.getAttribute('id');
                    const tocLink = document.querySelector(`.toc-link[href="#${id}"]`);
                    if (entry.isIntersecting && entry.intersectionRatio > 0.2) {
                        tocLinks.forEach(link => link.classList.remove('active'));
                        tocLink.classList.add('active');
                    }
                });
            }, { rootMargin: '-20% 0px -70% 0px' });
    
            sections.forEach(section => {
                observer.observe(section);
            });
    
            const flowSteps = document.querySelectorAll('.flow-step');
            flowSteps.forEach(step => {
                step.style.transition = 'transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out';
                step.addEventListener('mouseenter', () => {
                    step.style.transform = 'scale(1.03)';
                    step.style.boxShadow = '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)';
                });
                step.addEventListener('mouseleave', () => {
                    step.style.transform = 'scale(1)';
                    step.style.boxShadow = 'none';
                });
            });
        });
    
        function quiz() {
            return {
                questions: [
                    {
                        text: 'What is the primary difference between Authentication and Authorization?',
                        options: [
                            { text: 'Authentication determines permissions, Authorization verifies identity.', correct: false },
                            { text: 'Authentication verifies identity, Authorization determines permissions.', correct: true },
                            { text: 'They are the same process.', correct: false },
                            { text: 'Authentication uses policies, Authorization uses roles.', correct: false }
                        ],
                        explanation: 'Authentication is about "who you are" (verifying identity), while Authorization is about "what you can do" (determining permissions).',
                        answered: false,
                        selected: null
                    },
                     {
                        text: 'When is Resource-Based Authorization most appropriate?',
                        options: [
                            { text: 'When checking if a user has the "Admin" role.', correct: false },
                            { text: 'When checking if a user is over 21 years old.', correct: false },
                            { text: 'When the authorization decision depends on the properties of the item being accessed.', correct: true },
                            { text: 'It is never appropriate; role-based is always better.', correct: false }
                        ],
                        explanation: 'Resource-based auth is essential for "ownership" checks, like verifying if the current user is the author of the blog post they are trying to edit.',
                        answered: false,
                        selected: null
                    },
                    {
                        text: 'In a custom Authorization Handler, why should you avoid calling `context.Fail()`?',
                        options: [
                            { text: 'It throws an unhandled exception.', correct: false },
                            { text: 'It prevents other handlers for the same requirement from being evaluated.', correct: true },
                            { text: 'It logs a security warning that clutters the logs.', correct: false },
                            { text: '`context.Fail()` does not exist; you must use `context.Succeed(false)`.', correct: false }
                        ],
                        explanation: 'A policy fails only if no handler succeeds. Calling `Fail()` would short-circuit this process, preventing a potentially valid handler from granting access.',
                        answered: false,
                        selected: null
                    },
                     {
                        text: 'What is the main drawback of relying solely on Role-Based Authorization in a complex application?',
                        options: [
                            { text: 'It is difficult to implement.', correct: false },
                            { text: 'It can lead to "role explosion" and is not granular enough for fine-grained checks.', correct: true },
                            { text: 'It is less performant than policy-based authorization.', correct: false },
                            { text: 'It requires storing roles in a separate database.', correct: false }
                        ],
                        explanation: 'As application complexity grows, you may need many slightly different roles (role explosion), and RBAC cannot handle resource-specific rules well.',
                        answered: false,
                        selected: null
                    }
                ],
                selectOption(questionIndex, optionIndex) {
                    if (this.questions[questionIndex].answered) return;
                    this.questions[questionIndex].selected = optionIndex;
                    this.questions[questionIndex].answered = true;
                }
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-800" x-data>
    <!-- Chosen Palette: Warm Neutrals (Slate, Sky Blue Accent) -->
    <!-- Application Structure Plan: A comprehensive, single-page educational module with a two-column layout. The left, wider column contains the core lesson content in a logical, top-down flow, starting from foundational theory and progressing to advanced practical application. The right column features a sticky Table of Contents for easy navigation through the lesson. This structure was chosen because it's ideal for learning, allowing users to either follow the lesson sequentially or jump directly to specific topics of interest, enhancing usability and knowledge retention. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Authentication vs. Authorization Flow -> Goal: Clarify process -> Viz/Presentation: Interactive HTML/CSS flowchart -> Interaction: On-hover highlighting of steps -> Justification: Visually separates and explains the two distinct but related concepts in a request pipeline. Library/Method: Vanilla JS + Tailwind CSS.
        - Report Info: Role-based vs. Policy-based -> Goal: Compare concepts -> Viz/Presentation: Detailed comparison table -> Interaction: Static content -> Justification: A table provides a clear, side-by-side breakdown of features, pros, and cons for effective comparison. Library/Method: HTML/Tailwind.
        - Report Info: UML for Role Management -> Goal: Show data structure -> Viz/Presentation: HTML/CSS schema diagram -> Interaction: Static -> Justification: A visual representation of database tables (Users, Roles, UserRoles) is more concrete and practical for developers than a formal UML diagram in this context. Library/Method: HTML/Tailwind.
        - Report Info: Coding examples -> Goal: Teach practical implementation -> Viz/Presentation: Syntax-highlighted code blocks -> Interaction: Copy-to-clipboard button -> Justification: Makes it easy for learners to grab and use the code, reducing friction. Library/Method: Vanilla JS.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <div class="bg-slate-100/80 border-b border-slate-200">
        <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8 relative">
            <header class="text-center">
                <h1 class="text-4xl sm:text-5xl font-extrabold text-slate-800 mt-1 tracking-tight font-lexend">Low-Level Design Bootcamp</h1>
                <p class="mt-3 text-slate-600 max-w-xl mx-auto">Your 60-Day Interactive Roadmap to Mastering Backend Engineering.</p>
            </header>
            <a href="roadmap.html?week=8" class="absolute top-1/2 -translate-y-1/2 right-4 sm:right-6 lg:right-8 bg-slate-200 text-slate-700 text-sm font-semibold py-2 px-4 rounded-lg hover:bg-slate-300 transition-colors shadow-sm">
                Return to Homepage
            </a>
        </div>
    </div>
    
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div class="lg:grid lg:grid-cols-12 lg:gap-8">
            
            <main class="lg:col-span-9 space-y-16">
                <header>
                    <p class="text-sm font-semibold text-sky-500">Day 54: MVC & Middleware</p>
                    <h1 class="text-4xl font-extrabold text-slate-900 mt-2 font-lexend tracking-tight">Authorization: Role-Based & Policy-Based</h1>
                    <p class="mt-4 text-lg text-slate-600">Master the art of securing your application's resources. Today, we move beyond identifying users to defining what they can actually *do*, exploring the two dominant paradigms of access control in modern web APIs.</p>
                </header>

                <section id="section-1">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Introduction: Who Are You vs. What Can You Do?</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        Yesterday, we focused on <strong>Authentication</strong>—the process of verifying a user's identity, essentially answering the question, "Who are you?". Once we know who the user is, the next logical and critical step is <strong>Authorization</strong>. This process determines whether an authenticated user has the necessary permissions to perform a specific action or access a particular resource. It answers the question, "What are you allowed to do?".
                    </p>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        Without robust authorization, even a perfectly authenticated user could access or modify data they shouldn't, leading to massive security vulnerabilities. It's the gatekeeper that stands between a user's identity and your application's sensitive data and functionality.
                    </p>
                    <div class="mt-6 p-4 bg-sky-50 border border-sky-200 rounded-lg">
                        <p class="font-semibold text-sky-800">Analogy: The High-Security Facility</p>
                        <p class="mt-2 text-sky-700 text-sm space-y-1">
                            <strong>Authentication</strong> is showing your government-issued photo ID at the main gate. The guard verifies your face matches the ID and confirms you are on the list of approved personnel. You are now "in the facility".
                            <br>
                            <strong>Authorization</strong> is the electronic keycard you carry. The keycard (your JWT token) is encoded with your access levels (your claims and roles). Tapping it on a door reader checks if you have permission for that specific room.
                            <br>
                            - Accessing the cafeteria? General access, everyone's card works. `[Authorize]`
                            <br>
                            - Entering the laboratory? You need a "Scientist" level clearance. `[Authorize(Roles = "Scientist")]`
                            <br>
                            - Accessing the primary reactor control room? You need "Lead Engineer" clearance AND have passed a recent safety certification. This is a complex rule that requires a specific policy check. `[Authorize(Policy = "CanAccessReactor")]`
                        </p>
                    </div>
                </section>

                <section id="section-2" class="space-y-8">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Core Theory: The Building Blocks of Access Control</h2>
                    
                    <div>
                        <h3 class="text-2xl font-semibold text-slate-800 font-lexend">1. Claims-Based Authorization: The True Foundation</h3>
                        <p class="mt-3 text-slate-700 leading-relaxed">
                           At the heart of modern authorization is the concept of a <strong>claim</strong>. A claim is a statement about a subject (the user) made by a trusted issuer. It's a simple key-value pair. Roles and policies are ultimately abstractions built on top of claims. Your application's security decisions are based on the presence, absence, or value of these claims.
                        </p>
                        <p class="mt-3 text-slate-700 leading-relaxed">
                            In ASP.NET Core, the authenticated user is represented by a `ClaimsPrincipal`, which contains one or more `ClaimsIdentity` objects. Each identity is a collection of claims. This structure lets you reason about a user's attributes in a standardized way.
                        </p>
                        <div class="mt-4 p-4 bg-slate-100 border border-slate-200 rounded-lg">
                            <p class="font-semibold text-slate-800">Example: Decoded JWT Payload (The Claims)</p>
                            <pre class="text-sm text-slate-700 mt-2 bg-slate-200 p-2 rounded"><code class="language-json">{
  "sub": "auth0|12345abcdef", // Subject - the user's unique ID
  "email": "alice@example.com",
  "email_verified": true,
  "role": ["Admin", "Editor"], // A role is just a claim!
  "department": "Engineering", // Custom claim
  "exp": 1678886400 // Expiration time
}</code></pre>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-slate-800 font-lexend">2. Role-Based Authorization (RBAC)</h3>
                        <p class="mt-3 text-slate-700 leading-relaxed">
                            Role-based authorization is a coarse-grained mechanism. You group permissions into roles and assign users to those roles. It's simple, declarative, and excellent for scenarios where user types have clearly distinct capabilities.
                        </p>
                        <blockquote class="mt-4 border-l-4 border-slate-300 pl-4 py-2 text-slate-600">
                            <strong>How it works:</strong> The `[Authorize(Roles = "Admin")]` attribute is essentially a shortcut. Under the hood, it checks if the user's `ClaimsPrincipal` has a claim where the `Type` is `ClaimTypes.Role` and the `Value` is "Admin".
                        </blockquote>
                        <div class="grid md:grid-cols-2 gap-4 mt-4">
                            <div class="bg-green-50 border border-green-200 p-4 rounded-lg">
                                <h4 class="font-semibold text-green-800">Pros of RBAC</h4>
                                <ul class="list-disc list-inside mt-2 text-sm text-green-700 space-y-1">
                                    <li>Easy to understand and implement.</li>
                                    <li>Reduces complexity for simple systems.</li>
                                    <li>Easy to manage user permissions by changing their role.</li>
                                </ul>
                            </div>
                            <div class="bg-red-50 border border-red-200 p-4 rounded-lg">
                                <h4 class="font-semibold text-red-800">Cons of RBAC</h4>
                                <ul class="list-disc list-inside mt-2 text-sm text-red-700 space-y-1">
                                    <li>Inflexible for fine-grained control.</li>
                                    <li>Can lead to "role explosion" (too many roles).</li>
                                    <li>Tightly couples controllers to static role names.</li>
                                    <li>Doesn't work for checks against a resource (e.g., "is user the author of this post?").</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-slate-800 font-lexend">3. Policy-Based Authorization</h3>
                        <p class="mt-3 text-slate-700 leading-relaxed">
                            Policy-based authorization provides fine-grained control by decoupling authorization logic from your application code. You define named policies at startup, and your controllers simply refer to those policies. This makes your authorization rules reusable, testable, and easier to manage.
                        </p>
                        <p class="mt-3 text-slate-700 leading-relaxed font-semibold">The Core Components:</p>
                        <ul class="list-decimal list-inside mt-2 text-slate-700 space-y-2">
                            <li><strong>Policy:</strong> A named set of requirements. Registered in `Program.cs`.</li>
                            <li><strong>Requirement (`IAuthorizationRequirement`):</strong> A marker class that holds parameters for a policy. For example, `MinimumAgeRequirement` might hold the required age.</li>
                            <li><strong>Handler (`AuthorizationHandler<T>`):</strong> The class that contains the logic to evaluate a requirement. A handler checks the user's claims (or other data) against the requirement's parameters and decides if the requirement is met by calling `context.Succeed(requirement)`.</li>
                        </ul>
                         <div class="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                            <p class="font-semibold text-yellow-800">Important Subtlety: Handlers and `Fail()`</p>
                            <p class="mt-2 text-yellow-700 text-sm">
                                You rarely call `context.Fail()`. If a handler determines a user doesn't meet its specific requirement, it should simply do nothing and return. This allows other handlers for the same requirement to be evaluated. A policy only fails if **no handler succeeds** for a given requirement.
                            </p>
                        </div>
                    </div>
                    
                    <div>
                         <h3 class="text-2xl font-semibold text-slate-800 font-lexend">4. Resource-Based Authorization</h3>
                        <p class="mt-3 text-slate-700 leading-relaxed">
                            This is an advanced form of policy-based authorization where the decision depends not only on the user, but also on the specific resource being accessed. This is crucial for "ownership" checks. The question is no longer "Can this user edit documents?" but "Can this user edit *this particular document*?".
                        </p>
                        <blockquote class="mt-4 border-l-4 border-slate-300 pl-4 py-2 text-slate-600">
                             <strong>How it works:</strong> Instead of using an `[Authorize]` attribute, you inject the `IAuthorizationService` into your controller. Inside your action method, you fetch the resource (e.g., a blog post from the database) and then call `authorizationService.AuthorizeAsync(User, resource, policyName)`. This passes the resource object itself to your authorization handler, allowing your logic to inspect its properties (like `post.AuthorId`).
                        </blockquote>
                    </div>

                </section>

                <section id="section-3">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Interactive Flow: A Request's Journey</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        Hover over the steps below to see how a typical request flows through the authentication and authorization middleware in an ASP.NET Core application. Notice the distinct points where identity is checked versus where permissions are verified.
                    </p>
                    <div id="flow-diagram" class="mt-6 p-6 bg-white border rounded-lg space-y-4">
                        <div class="flow-step p-4 rounded-md border" data-step="1">
                            <div class="font-bold text-lg text-slate-800">1. Incoming Request</div>
                            <div class="text-sm text-slate-600">A request arrives for `GET /api/documents/123`. The request includes an `Authorization: Bearer <JWT>` header.</div>
                        </div>
                        <div class="flex justify-center">
                            <div class="text-2xl text-slate-400">&darr;</div>
                        </div>
                        <div class="flow-step p-4 rounded-md border" data-step="2">
                            <div class="font-bold text-lg text-slate-800">2. Authentication Middleware</div>
                            <div class="text-sm text-slate-600">This middleware finds the JWT, validates its signature and expiration, and deserializes its payload into a set of claims. It constructs a `ClaimsPrincipal` object representing the user and attaches it to the request context. If the token is invalid or missing, it immediately returns `401 Unauthorized`.</div>
                        </div>
                        <div class="flex justify-center">
                            <div class="text-2xl text-slate-400">&darr;</div>
                        </div>
                        <div class="flow-step p-4 rounded-md border" data-step="3">
                            <div class="font-bold text-lg text-slate-800">3. Authorization Middleware</div>
                            <div class="text-sm text-slate-600">This middleware examines the endpoint the request is routed to. It finds an `[Authorize(Policy = "CanEditDocument")]` attribute. It then invokes the registered handlers for that policy, passing in the user's `ClaimsPrincipal`.</div>
                        </div>
                        <div class="flex justify-center space-x-16">
                            <div class="text-2xl text-red-400">&swarr;</div>
                            <div class="text-2xl text-green-400">&searr;</div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="flow-step p-4 rounded-md border border-red-200 bg-red-50" data-step="4a">
                                <div class="font-bold text-lg text-red-600">4a. Access Denied</div>
                                <div class="text-sm text-slate-600">If no handler for the "CanEditDocument" policy succeeds, the middleware short-circuits the pipeline and returns a `403 Forbidden` response. The controller's action method is never executed.</div>
                            </div>
                            <div class="flow-step p-4 rounded-md border border-green-200 bg-green-50" data-step="4b">
                                <div class="font-bold text-lg text-green-600">4b. Access Granted</div>
                                <div class="text-sm text-slate-600">If at least one handler for the policy succeeds, the request is allowed to proceed. The middleware calls the next piece of middleware in the pipeline, which eventually invokes the controller's action method.</div>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="section-4" class="space-y-8">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Coding Practice: From Theory to Implementation</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        Let's apply these concepts in a practical C# ASP.NET Core context. We'll build up from adding roles to a JWT to creating complex, combined policies.
                    </p>

                    <div>
                        <h3 class="text-2xl font-semibold text-slate-800 font-lexend">Task 1: Add Roles & Custom Claims to JWT Tokens</h3>
                        <p class="mt-2 text-slate-700">When generating a JWT, we include claims that our authorization policies will rely on.</p>
                        <div class="code-block mt-4">
                            <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">// This method generates a token after a user has successfully logged in.
public string GenerateJwtToken(User user, IList&lt;string&gt; roles)
{
    var claims = new List&lt;Claim&gt;
    {
        // Standard claims (defined by JWT spec)
        new Claim(JwtRegisteredClaimNames.Sub, user.Id), // 'sub' is the standard claim for user ID
        new Claim(JwtRegisteredClaimNames.Email, user.Email),
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), // 'jti' provides a unique token ID for preventing replay attacks

        // Custom claims specific to your application
        new Claim("department", user.Department),
        new Claim(ClaimTypes.DateOfBirth, user.DateOfBirth.ToString("yyyy-MM-dd"))
    };

    // Add role claims. The framework specifically looks for ClaimTypes.Role.
    foreach (var role in roles)
    {
        claims.Add(new Claim(ClaimTypes.Role, role));
    }
    
    // ... JWT generation logic using SymmetricSecurityKey ...
    // (Omitted for brevity)
    return "generated.jwt.token";
}</code></pre>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-2xl font-semibold text-slate-800 font-lexend">[Medium] Task 2: Create a Custom Policy (Age & Department)</h3>
                        <p class="mt-2 text-slate-700">Let's create a policy named `EngineeringManager`. An engineering manager must be in the "Engineering" department and also hold the "Manager" role.</p>
                        
                        <h4 class="font-semibold mt-4 text-slate-700">Step A: Register the Policy in Program.cs</h4>
                        <p class="text-sm text-slate-600">For this simple case, we don't need a custom Requirement or Handler. We can use built-in helpers.</p>
                         <div class="code-block mt-2">
                            <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">builder.Services.AddAuthorization(options =>
{
    // A user must satisfy ALL chained requirements to pass the policy.
    options.AddPolicy("EngineeringManager", policy =>
    {
        policy.RequireRole("Manager");
        policy.RequireClaim("department", "Engineering");
    });
});</code></pre>
                        </div>

                         <h4 class="font-semibold mt-4 text-slate-700">Step B: Use the Policy</h4>
                         <div class="code-block mt-2">
                             <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">[HttpGet("deployment-plans")]
[Authorize(Policy = "EngineeringManager")]
public IActionResult GetDeploymentPlans()
{
    return Ok("Here are the top-secret deployment plans.");
}</code></pre>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-2xl font-semibold text-slate-800 font-lexend">[Hard] Task 3: Resource-Based Authorization (Document Ownership)</h3>
                        <p class="mt-2 text-slate-700">Now for the most powerful pattern. We'll create a policy to ensure only the author of a document can edit it.</p>
                        
                        <h4 class="font-semibold mt-4 text-slate-700">Step A: Create the Requirement</h4>
                        <p class="text-sm text-slate-600">This is just a marker to identify our operation.</p>
                        <div class="code-block mt-2">
                            <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">public class SameAuthorRequirement : IAuthorizationRequirement { }</code></pre>
                        </div>

                        <h4 class="font-semibold mt-4 text-slate-700">Step B: Create the Handler</h4>
                        <p class="text-sm text-slate-600">The handler contains the logic. Notice it takes a `Document` as a resource.</p>
                         <div class="code-block mt-2">
                             <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">// Document is a placeholder for your actual entity/model class
public class Document { public string Id { get; set; } public string AuthorId { get; set; } }

public class DocumentAuthorizationHandler : AuthorizationHandler&lt;SameAuthorRequirement, Document&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, 
        SameAuthorRequirement requirement, 
        Document resource)
    {
        // Get the current user's ID from their claims. 'Sub' is the standard ID claim.
        string userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier);
        
        if (userId != null && resource.AuthorId == userId)
        {
            // The user is the author, so the requirement is met.
            context.Succeed(requirement);
        }
        
        // If we don't call Succeed, access is implicitly denied.
        return Task.CompletedTask;
    }
}</code></pre>
                        </div>

                        <h4 class="font-semibold mt-4 text-slate-700">Step C: Register Handler and Define Policy</h4>
                        <div class="code-block mt-2">
                            <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">// 1. Register the handler with DI
builder.Services.AddSingleton&lt;IAuthorizationHandler, DocumentAuthorizationHandler&gt;();

// 2. Add the authorization policy
builder.Services.AddAuthorization(options =>
{
    // This policy is now associated with our requirement.
    options.AddPolicy("MustOwnDocument", policy =>
        policy.AddRequirements(new SameAuthorRequirement()));
});</code></pre>
                        </div>

                         <h4 class="font-semibold mt-4 text-slate-700">Step D: Use the Policy Imperatively in a Controller</h4>
                         <div class="code-block mt-2">
                             <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">[ApiController]
public class DocumentsController : ControllerBase
{
    private readonly IDocumentRepository _repo;
    private readonly IAuthorizationService _authorizationService;

    public DocumentsController(IDocumentRepository repo, IAuthorizationService authorizationService)
    {
        _repo = repo;
        _authorizationService = authorizationService;
    }

    [HttpPut("{id}")]
    public async Task&lt;IActionResult&gt; UpdateDocument(string id, [FromBody] UpdateDto data)
    {
        Document documentToUpdate = await _repo.GetByIdAsync(id);
        if (documentToUpdate == null) return NotFound();

        // Here we perform the resource-based authorization check
        var authResult = await _authorizationService.AuthorizeAsync(User, documentToUpdate, "MustOwnDocument");

        if (!authResult.Succeeded)
        {
            // User is authenticated but not authorized for this specific resource.
            // Return 403 Forbidden or 404 NotFound to avoid leaking info.
            return Forbid(); 
        }

        // ... proceed with update logic ...
        return NoContent();
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="section-5">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Schema Design: From Simple RBAC to Granular Permissions</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        While the standard User/Role/UserRole schema is a good start, real-world systems often need more granular control. A more robust design introduces a `Permissions` table. This decouples permissions from role definitions, allowing you to create new permissions without changing code and assign them to roles dynamically.
                    </p>
                    <h4 class="font-semibold text-slate-700 mt-4">Advanced Schema: Role-Permission Model</h4>
                    <div class="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 items-start text-center">
                        <!-- Users -->
                        <div class="border rounded-lg p-3 bg-slate-50 shadow-sm"><h5 class="font-bold">Users</h5><hr class="my-1"><p class="text-xs">Id (PK)<br>Email</p></div>
                        <div class="mt-6 font-mono">&harr;</div>
                        <!-- UserRoles -->
                        <div class="border rounded-lg p-3 bg-sky-50 shadow-sm"><h5 class="font-bold text-sky-800">UserRoles</h5><hr class="my-1 border-sky-200"><p class="text-xs">UserId (FK)<br>RoleId (FK)</p></div>
                        <div class="mt-6 font-mono">&harr;</div>
                        <!-- Roles -->
                        <div class="border rounded-lg p-3 bg-slate-50 shadow-sm"><h5 class="font-bold">Roles</h5><hr class="my-1"><p class="text-xs">Id (PK)<br>Name</p></div>
                    </div>
                     <div class="flex justify-end mt-2 pr-12">
                        <div class="text-2xl text-slate-400">&darr;</div>
                     </div>
                     <div class="mt-2 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 items-start text-center justify-items-end">
                         <div></div><div></div><div></div>
                         <!-- RolePermissions -->
                         <div class="border rounded-lg p-3 bg-sky-50 shadow-sm"><h5 class="font-bold text-sky-800">RolePermissions</h5><hr class="my-1 border-sky-200"><p class="text-xs">RoleId (FK)<br>PermissionId (FK)</p></div>
                          <div class="mt-6 font-mono">&harr;</div>
                     </div>
                     <div class="mt-2 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 items-start text-center justify-items-end">
                         <div></div><div></div><div></div><div></div>
                         <!-- Permissions -->
                         <div class="border rounded-lg p-3 bg-slate-50 shadow-sm"><h5 class="font-bold">Permissions</h5><hr class="my-1"><p class="text-xs">Id (PK)<br>Name (e.g., "products:delete")</p></div>
                     </div>
                    <p class="mt-4 text-slate-700">With this schema, your JWT generation logic would query for all permissions associated with a user's roles and add them as custom `permission` claims to the token. Your policies could then check for these specific permissions instead of hardcoded roles.</p>
                </section>
                
                <section id="section-6">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Case Study: E-commerce API (Enhanced with Resource-Based Auth)</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                       Let's revisit our E-commerce API. The original `UpdateProduct` endpoint had a major flaw: any seller could update any other seller's product! We will fix this with a resource-based policy.
                    </p>
                    <div class="code-block mt-4">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">[ApiController]
[Route("api/[controller]")]
[Authorize] // Require authentication at the controller level
public class ProductsController : ControllerBase
{
    // ... constructor and other methods ...

    // To update a product, you must be a "Seller".
    // We also add a resource-based check to ensure they own the product.
    [HttpPut("{id}")]
    [Authorize(Roles = "Seller")] // Coarse-grained check: must be a seller
    public async Task&lt;IActionResult&gt; UpdateProduct(int id, [FromBody] ProductDto updatedProduct)
    {
        var product = await _productRepo.GetByIdAsync(id);
        if (product == null) return NotFound();

        // Fine-grained, resource-based check
        var authResult = await _authorizationService.AuthorizeAsync(User, product, "MustBeProductOwner");
        if (!authResult.Succeeded)
        {
            // You are a seller, but this is not your product.
            return Forbid();
        }
        
        // ... safe to proceed with update logic
        return NoContent();
    }
    
    // Only an "Admin" can delete any product from the system.
    // Admins bypass the ownership check.
    [HttpDelete("{id}")]
    [Authorize(Roles = "Admin")]
    public IActionResult DeleteProduct(int id)
    {
        // Logic to delete product by ID
        return NoContent();
    }
}

// And the handler for "MustBeProductOwner" would look very similar to our
// DocumentAuthorizationHandler, checking product.SellerId against the user's ID.</code></pre>
                    </div>
                </section>

                <section id="section-7" x-data="quiz()">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Knowledge Check</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        Test your understanding of the key concepts covered in this lesson.
                    </p>
                    <div class="mt-6 space-y-8">
                        <template x-for="(question, index) in questions" :key="index">
                            <div class="bg-white p-6 rounded-lg border border-slate-200">
                                <p class="font-semibold" x-text="`${index + 1}. ${question.text}`"></p>
                                <div class="mt-4 space-y-3">
                                    <template x-for="(option, optionIndex) in question.options" :key="optionIndex">
                                        <button 
                                            @click="selectOption(index, optionIndex)"
                                            :disabled="question.answered"
                                            :class="{
                                                'selected': question.selected === optionIndex,
                                                'correct': question.answered && option.correct,
                                                'incorrect': question.answered && question.selected === optionIndex && !option.correct
                                            }"
                                            class="quiz-option w-full text-left p-3 border-2 border-slate-200 rounded-md hover:border-sky-400 transition-colors disabled:cursor-not-allowed disabled:opacity-70"
                                            x-text="option.text">
                                        </button>
                                    </template>
                                </div>
                                <div x-show="question.answered" class="mt-4 p-3 rounded-md text-sm" 
                                     :class="question.options[question.selected]?.correct ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'">
                                    <p x-show="question.options[question.selected]?.correct"><strong>Correct!</strong> <span x-text="question.explanation"></span></p>
                                    <p x-show="!question.options[question.selected]?.correct"><strong>Incorrect.</strong> <span x-text="question.explanation"></span></p>
                                </div>
                            </div>
                        </template>
                    </div>
                </section>

                <section id="section-8" x-data="{ open: false }">
                    <h2 class="text-3xl font-bold text-slate-900 font-lexend tracking-tight border-b pb-2">Self-Assessment Challenge</h2>
                    <p class="mt-4 text-slate-700 leading-relaxed">
                        Ready to put your skills to the test? Complete the following challenge to solidify your understanding.
                    </p>
                    <div class="mt-6 bg-white p-6 rounded-lg border border-slate-200">
                        <h3 class="font-semibold text-lg text-slate-800">Challenge: The "Contingency Access" Policy</h3>
                        <p class="mt-2 text-slate-600">
                            Implement a custom authorization policy named `"ContingencyAccess"`. Access should be granted if a user meets EITHER of the following conditions:
                        </p>
                        <ol class="list-decimal list-inside mt-3 space-y-1 text-slate-600">
                            <li>They have the role "Admin".</li>
                            <li>They have the role "OnCallEngineer" AND they have a claim `access_level` with a value of "5".</li>
                        </ol>
                        <p class="mt-3 text-slate-600">
                            This requires a custom policy handler. You will need to:
                            <br>1. Create a requirement `ContingencyAccessRequirement`.
                            <br>2. Create a handler `ContingencyAccessHandler`.
                            <br>3. Register the policy and handler in `Program.cs`.
                        </p>
                        <button @click="open = !open" class="mt-4 inline-flex items-center text-sm font-semibold text-sky-600 hover:text-sky-800">
                            <span x-text="open ? 'Hide Solution' : 'Show Solution'"></span>
                            <svg :class="{'rotate-180': open}" class="ml-1 w-4 h-4 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        <div x-show="open" x-cloak x-transition class="mt-4 pt-4 border-t">
                             <h4 class="font-semibold text-slate-700">Solution:</h4>
                             <div class="code-block mt-2">
                                <button class="copy-button" onclick="copyCode(this)">Copy</button>
                                <pre class="bg-slate-800 text-white p-4 rounded-lg overflow-x-auto"><code class="language-csharp">// 1. Requirement (just a marker)
public class ContingencyAccessRequirement : IAuthorizationRequirement { }

// 2. Handler (contains the OR logic)
public class ContingencyAccessHandler : AuthorizationHandler&lt;ContingencyAccessRequirement&gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, ContingencyAccessRequirement requirement)
    {
        // Condition 1: Is the user an Admin?
        if (context.User.IsInRole("Admin"))
        {
            context.Succeed(requirement);
            return Task.CompletedTask;
        }

        // Condition 2: Is the user an OnCallEngineer with access level 5?
        bool isOnCall = context.User.IsInRole("OnCallEngineer");
        bool hasAccessLevel = context.User.HasClaim("access_level", "5");

        if (isOnCall && hasAccessLevel)
        {
            context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
}

// 3. Registration in Program.cs
builder.Services.AddSingleton&lt;IAuthorizationHandler, ContingencyAccessHandler&gt;();
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("ContingencyAccess", policy => 
        policy.AddRequirements(new ContingencyAccessRequirement()));
});</code></pre>
                            </div>
                        </div>
                    </div>
                </section>
            </main>

            <aside class="hidden lg:block lg:col-span-3">
                <nav id="toc" class="sticky top-20">
                    <h3 class="font-semibold text-slate-900 mb-3">On this page</h3>
                    <ul class="space-y-2">
                        <li><a href="#section-1" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Introduction</a></li>
                        <li><a href="#section-2" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Core Theory</a></li>
                        <li><a href="#section-3" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Interactive Flow</a></li>
                        <li><a href="#section-4" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Coding Practice</a></li>
                        <li><a href="#section-5" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Schema Design</a></li>
                        <li><a href="#section-6" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Case Study</a></li>
                        <li><a href="#section-7" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Knowledge Check</a></li>
                        <li><a href="#section-8" class="toc-link block text-sm text-slate-600 border-l-2 border-transparent pl-3 hover:text-sky-500 hover:border-sky-500 transition-colors">Self-Assessment</a></li>
                    </ul>
                </nav>
            </aside>
        </div>
    </div>
    
    <footer class="text-center mt-16 py-8 border-t border-slate-200">
        <p class="text-slate-700 font-semibold">Low-Level Design Bootcamp</p>
        <p class="text-sm text-slate-500 mt-2">A personalized learning roadmap curated by Mr. Mahesh Singare.</p>
        <p class="text-xs text-slate-400 mt-4">&copy; 2025. All Rights Reserved.</p>
    </footer>

<script>
    function copyCode(button) {
        const codeBlock = button.nextElementSibling;
        const code = codeBlock.querySelector('code');
        navigator.clipboard.writeText(code.innerText).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => {
                button.textContent = 'Copy';
            }, 2000);
        });
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        const tocLinks = document.querySelectorAll('.toc-link');
        const sections = document.querySelectorAll('main section');

        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                const id = entry.target.getAttribute('id');
                const tocLink = document.querySelector(`.toc-link[href="#${id}"]`);
                if (entry.isIntersecting && entry.intersectionRatio > 0.2) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    tocLink.classList.add('active');
                }
            });
        }, { rootMargin: '-20% 0px -70% 0px' });

        sections.forEach(section => {
            observer.observe(section);
        });

        const flowSteps = document.querySelectorAll('.flow-step');
        flowSteps.forEach(step => {
            step.style.transition = 'transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out';
            step.addEventListener('mouseenter', () => {
                step.style.transform = 'scale(1.03)';
                step.style.boxShadow = '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)';
            });
            step.addEventListener('mouseleave', () => {
                step.style.transform = 'scale(1)';
                step.style.boxShadow = 'none';
            });
        });
    });

    function quiz() {
        return {
            questions: [
                {
                    text: 'What is the primary difference between Authentication and Authorization?',
                    options: [
                        { text: 'Authentication determines permissions, Authorization verifies identity.', correct: false },
                        { text: 'Authentication verifies identity, Authorization determines permissions.', correct: true },
                        { text: 'They are the same process.', correct: false },
                        { text: 'Authentication uses policies, Authorization uses roles.', correct: false }
                    ],
                    explanation: 'Authentication is about "who you are" (verifying identity), while Authorization is about "what you can do" (determining permissions).',
                    answered: false,
                    selected: null
                },
                 {
                    text: 'When is Resource-Based Authorization most appropriate?',
                    options: [
                        { text: 'When checking if a user has the "Admin" role.', correct: false },
                        { text: 'When checking if a user is over 21 years old.', correct: false },
                        { text: 'When the authorization decision depends on the properties of the item being accessed.', correct: true },
                        { text: 'It is never appropriate; role-based is always better.', correct: false }
                    ],
                    explanation: 'Resource-based auth is essential for "ownership" checks, like verifying if the current user is the author of the blog post they are trying to edit.',
                    answered: false,
                    selected: null
                },
                {
                    text: 'In a custom Authorization Handler, why should you avoid calling `context.Fail()`?',
                    options: [
                        { text: 'It throws an unhandled exception.', correct: false },
                        { text: 'It prevents other handlers for the same requirement from being evaluated.', correct: true },
                        { text: 'It logs a security warning that clutters the logs.', correct: false },
                        { text: '`context.Fail()` does not exist; you must use `context.Succeed(false)`.', correct: false }
                    ],
                    explanation: 'A policy fails only if no handler succeeds. Calling `Fail()` would short-circuit this process, preventing a potentially valid handler from granting access.',
                    answered: false,
                    selected: null
                },
                 {
                    text: 'What is the main drawback of relying solely on Role-Based Authorization in a complex application?',
                    options: [
                        { text: 'It is difficult to implement.', correct: false },
                        { text: 'It can lead to "role explosion" and is not granular enough for fine-grained checks.', correct: true },
                        { text: 'It is less performant than policy-based authorization.', correct: false },
                        { text: 'It requires storing roles in a separate database.', correct: false }
                    ],
                    explanation: 'As application complexity grows, you may need many slightly different roles (role explosion), and RBAC cannot handle resource-specific rules well.',
                    answered: false,
                    selected: null
                }
            ],
            selectOption(questionIndex, optionIndex) {
                if (this.questions[questionIndex].answered) return;
                this.questions[questionIndex].selected = optionIndex;
                this.questions[questionIndex].answered = true;
            }
        }
    }
</script>
</body>
</html>

