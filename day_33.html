<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 33: Adapter Pattern - LLD Bootcamp</title>
    <!-- Chosen Palette: Warm Neutrals (Slate, Zinc, Amber) -->
    <!-- Application Structure Plan: A two-column layout is chosen for optimal learning experience. The left, wider column contains the core lesson content, flowing logically from theory to practical application. The right, narrower column features a sticky table of contents (TOC) for easy navigation. This structure allows users to both follow the lesson sequentially or jump to specific sections of interest. Interactions include copy-to-clipboard for code, an interactive quiz with immediate feedback, and accordions for revealing solutions, fostering an engaging, self-paced learning environment. This is superior to a simple linear page as it provides context and control to the learner. -->
    <!-- Visualization & Content Choices: Report Info: UML Diagram -> Goal: Organize/Structure -> Viz Method: HTML/Tailwind Diagram -> Interaction: Hover for details -> Justification: An interactive diagram is more engaging than a static image and helps visualize class relationships effectively. Report Info: Coding examples -> Goal: Inform/Practice -> Presentation Method: Syntax-highlighted code blocks -> Interaction: Copy-to-clipboard button -> Justification: Facilitates easy use of code snippets. Report Info: Quizzes -> Goal: Assess -> Presentation Method: Interactive multiple-choice questions -> Interaction: Click to select, instant feedback -> Justification: Active recall strengthens learning. All choices avoid SVG/Mermaid as required, using standard web tech for a rich, self-contained experience. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700;800&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .font-lexend { font-family: 'Lexend', sans-serif; }
        .toc-link.active {
            color: #d97706; /* amber-600 */
            font-weight: 600;
            border-left-color: #d97706; /* amber-600 */
        }
        .code-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            padding: 0.25rem 0.6rem;
            font-size: 0.75rem;
            border-radius: 0.375rem;
            cursor: pointer;
            background-color: #e2e8f0; /* slate-200 */
            color: #475569; /* slate-600 */
            transition: all 0.2s;
        }
        .copy-button:hover {
            background-color: #cbd5e1; /* slate-300 */
        }
        .quiz-option:hover {
            background-color: #f1f5f9; /* slate-100 */
        }
        .quiz-option[data-selected="true"][data-correct="true"] {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e; /* green-500 */
        }
        .quiz-option[data-selected="true"][data-correct="false"] {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
        }
        [x-cloak] { display: none !important; }
        .uml-diagram .component {
            transition: all 0.3s ease;
        }
        .uml-diagram .component:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
</head>
<body x-data="adapterPatternPage()">
    <div class="bg-slate-100/80 border-b border-slate-200">
        <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8 relative">
            <header class="text-center">
                <h1 class="text-4xl sm:text-5xl font-extrabold text-slate-800 mt-1 tracking-tight font-lexend">Low-Level Design Bootcamp</h1>
                <p class="mt-3 text-slate-600 max-w-xl mx-auto">Your 60-Day Interactive Roadmap to Mastering Backend Engineering.</p>
            </header>
            <a href="roadmap.html?week=5" class="absolute top-1/2 -translate-y-1/2 right-4 sm:right-6 lg:right-8 bg-slate-200 text-slate-700 text-sm font-semibold py-2 px-4 rounded-lg hover:bg-slate-300 transition-colors shadow-sm">
                Return to Homepage
            </a>
        </div>
    </div>

    <main class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8 mt-8">
        <div class="flex flex-col lg:flex-row lg:space-x-12">
            <!-- Main Content -->
            <div class="w-full lg:w-3/4">
                <article class="prose max-w-none prose-slate prose-h2:font-lexend prose-h2:text-3xl prose-h2:mb-4 prose-h3:font-lexend prose-h3:text-2xl prose-h3:mb-3">
                    <div class="flex items-center space-x-4 mb-8">
                        <div class="bg-amber-100 text-amber-700 font-bold text-2xl rounded-lg w-16 h-16 flex items-center justify-center">33</div>
                        <div>
                            <p class="text-slate-500 m-0">Creational Design Patterns (Days 29–35)</p>
                            <h2 class="m-0 p-0 !mb-0">Adapter Pattern</h2>
                        </div>
                    </div>
                    
                    <section id="theory" class="scroll-mt-24">
                        <h3>✅ Theory Topics</h3>
                        <p>The Adapter pattern is a structural design pattern that allows objects with incompatible interfaces to collaborate. Think of it as a universal travel adapter for your code, enabling different components to "plug in" and work together seamlessly, even if they weren't originally designed to.</p>

                        <div class="bg-amber-50 border-l-4 border-amber-400 p-4 rounded-r-lg my-6">
                            <h4 class="font-bold text-amber-800">Analogy: The Power Adapter</h4>
                            <p class="text-amber-700">Imagine you have a laptop with a US plug, but you're in Europe where the wall sockets are different. You can't plug your laptop in directly. What do you do? You use a power adapter. The adapter fits into the European socket on one end and accepts your US plug on the other. It doesn't change your laptop or the wall socket; it simply translates between the two, making them compatible. The Adapter pattern does the exact same thing for your code's interfaces.</p>
                        </div>
                        
                        <h4 class="font-semibold text-xl mt-6">Adapter Definition</h4>
                        <p>The Adapter pattern acts as a wrapper around an existing class (the "Adaptee") to provide a different interface (the "Target") that a client expects. It translates requests from the client's interface into calls that the adaptee's interface can understand.</p>
                        <div class="bg-slate-800 text-white rounded-lg p-4 my-4 code-block">
                            <button @click="copyToClipboard($event)" class="copy-button">Copy</button>
                            <pre><code class="language-csharp">
// The Target interface that the client code expects.
public interface ITarget
{
    string GetRequest();
}

// The Adaptee - an existing class with an incompatible interface.
public class Adaptee
{
    public string GetSpecificRequest()
    {
        return "Specific request.";
    }
}

// The Adapter makes the Adaptee's interface compatible with the Target's.
public class Adapter : ITarget
{
    private readonly Adaptee _adaptee;

    public Adapter(Adaptee adaptee)
    {
        _adaptee = adaptee;
    }

    public string GetRequest()
    {
        // Translation happens here
        return $"This is a translated '{_adaptee.GetSpecificRequest()}'";
    }
}
</code></pre>
                        </div>
                        
                        <h4 class="font-semibold text-xl mt-6">Legacy System Integration</h4>
                        <p>One of the most common and powerful uses of the Adapter pattern is integrating modern systems with legacy code. Often, you're working with a valuable, time-tested legacy component, but its API is outdated or doesn't match the interfaces of your new application. Rewriting the legacy code is risky and expensive. The Adapter pattern provides an elegant solution by creating a modern, clean interface that wraps the old one without modifying the original source code.</p>
                        
                        <h4 class="font-semibold text-xl mt-6">Adapter vs. Facade</h4>
                        <p>While both patterns are wrappers that simplify interaction with other objects, their intent is fundamentally different. An adapter's primary goal is to change an interface, while a facade's goal is to simplify a complex subsystem.</p>

                        <div class="overflow-x-auto my-6">
                            <table class="w-full text-left border-collapse">
                                <thead>
                                    <tr>
                                        <th class="border border-slate-300 p-3 bg-slate-100 font-semibold">Aspect</th>
                                        <th class="border border-slate-300 p-3 bg-slate-100 font-semibold">Adapter Pattern</th>
                                        <th class="border border-slate-300 p-3 bg-slate-100 font-semibold">Facade Pattern</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="border border-slate-300 p-3 font-semibold">Intent</td>
                                        <td class="border border-slate-300 p-3">To make two incompatible interfaces work together.</td>
                                        <td class="border border-slate-300 p-3">To provide a simplified, high-level interface to a complex subsystem.</td>
                                    </tr>
                                    <tr>
                                        <td class="border border-slate-300 p-3 font-semibold">Analogy</td>
                                        <td class="border border-slate-300 p-3">A travel power adapter.</td>
                                        <td class="border border-slate-300 p-3">A customer service representative at a large company.</td>
                                    </tr>
                                    <tr>
                                        <td class="border border-slate-300 p-3 font-semibold">Scope</td>
                                        <td class="border border-slate-300 p-3">Wraps a single object (the Adaptee).</td>
                                        <td class="border border-slate-300 p-3">Coordinates multiple objects within a subsystem.</td>
                                    </tr>
                                    <tr>
                                        <td class="border border-slate-300 p-3 font-semibold">Focus</td>
                                        <td class="border border-slate-300 p-3">Interface conversion.</td>
                                        <td class="border border-slate-300 p-3">Subsystem simplification.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </section>

                    <section id="uml" class="scroll-mt-24 mt-12">
                        <h3>✅ UML/Schema Task</h3>
                        <p>The UML diagram for the Adapter pattern clearly illustrates the relationships between the Client, the Target interface it uses, the Adaptee with its incompatible interface, and the Adapter that bridges the gap.</p>
                        <div class="bg-white p-6 rounded-lg shadow-md border border-slate-200 my-6 uml-diagram">
                            <h4 class="text-center font-bold text-slate-700 mb-6">Adapter Pattern UML Diagram</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center relative">
                                <!-- Dashed lines for relationships -->
                                <div class="absolute top-1/4 left-1/4 w-1/2 h-1/2 hidden md:block">
                                    <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
                                        <line x1="50%" y1="0" x2="0" y2="50%" stroke="#64748b" stroke-width="2" stroke-dasharray="5,5"/>
                                        <line x1="50%" y1="0" x2="100%" y2="50%" stroke="#64748b" stroke-width="2" />
                                        <path d="M 98% 50% L 90% 45% L 90% 55% Z" fill="#64748b" />
                                        <line x1="100%" y1="50%" x2="50%" y2="100%" stroke="#64748b" stroke-width="2" stroke-dasharray="5,5"/>
                                    </svg>
                                </div>
                                
                                <div class="md:col-start-2 justify-self-center component">
                                    <div class="bg-blue-100 border-2 border-blue-400 rounded-lg p-4 text-center w-48">
                                        <p class="font-bold text-blue-800">Client</p>
                                        <hr class="border-blue-400 my-2">
                                        <p class="text-sm text-blue-700">Uses ITarget</p>
                                    </div>
                                </div>

                                <div class="justify-self-center component">
                                     <div class="bg-green-100 border-2 border-green-400 rounded-lg p-4 text-center w-48">
                                        <p class="font-bold text-green-800">&lt;&lt;interface&gt;&gt;<br>ITarget</p>
                                        <hr class="border-green-400 my-2">
                                        <p class="text-sm text-green-700">+ Request()</p>
                                    </div>
                                </div>
                                <div class="justify-self-center component md:col-start-2">
                                    <div class="bg-purple-100 border-2 border-purple-400 rounded-lg p-4 text-center w-48">
                                        <p class="font-bold text-purple-800">Adapter</p>
                                        <hr class="border-purple-400 my-2">
                                        <p class="text-sm text-purple-700">- adaptee: Adaptee<br>+ Request()</p>
                                    </div>
                                </div>
                                <div class="md:col-span-2 justify-self-center component">
                                    <div class="bg-red-100 border-2 border-red-400 rounded-lg p-4 text-center w-48">
                                        <p class="font-bold text-red-800">Adaptee</p>
                                        <hr class="border-red-400 my-2">
                                        <p class="text-sm text-red-700">+ SpecificRequest()</p>
                                    </div>
                                </div>
                            </div>
                            <p class="text-center text-sm text-slate-500 mt-6">Hover over components to see them highlight. The diagram shows the Client interacting with the Target interface. The Adapter implements this interface, but internally it delegates the call to the Adaptee, translating the request.</p>
                        </div>
                    </section>
                    
                    <section id="coding-practice" class="scroll-mt-24 mt-12">
                        <h3>✅ Coding Practice</h3>
                        <p>Let's solidify the theory with some hands-on coding examples in C#. Each example tackles a common scenario where the Adapter pattern is the perfect solution.</p>

                        <div x-data="{ open: false }" class="bg-white border border-slate-200 rounded-lg shadow-sm my-6">
                            <button @click="open = !open" class="w-full text-left p-4 font-semibold text-slate-800 flex justify-between items-center">
                                <span>[Easy] Shape Adapter</span>
                                <svg :class="{'rotate-180': open}" class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </button>
                            <div x-show="open" x-cloak class="p-4 border-t border-slate-200">
                                <p class="mb-4"><strong>Problem:</strong> You have a modern drawing application that works with an `IShape` interface, which has a `Draw()` method. You need to integrate a legacy `LegacyRectangle` class that has a `Display(x1, y1, x2, y2)` method instead.</p>
                                <div class="bg-slate-800 text-white rounded-lg p-4 code-block">
                                    <button @click="copyToClipboard($event)" class="copy-button">Copy</button>
                                    <pre><code class="language-csharp">
// Target Interface
public interface IShape
{
    void Draw();
}

// Adaptee: Legacy Class
public class LegacyRectangle
{
    public void Display(int x1, int y1, int x2, int y2)
    {
        Console.WriteLine($"Legacy Rectangle from ({x1},{y1}) to ({x2},{y2})");
    }
}

// Adapter Class
public class ShapeAdapter : IShape
{
    private readonly LegacyRectangle _legacyRectangle;
    private readonly int _x1, _y1, _x2, _y2;

    public ShapeAdapter(LegacyRectangle legacyRectangle, int x1, int y1, int x2, int y2)
    {
        _legacyRectangle = legacyRectangle;
        _x1 = x1;
        _y1 = y1;
        _x2 = x2;
        _y2 = y2;
    }

    public void Draw()
    {
        // Translate the Draw() call to the Display() call
        _legacyRectangle.Display(_x1, _y1, _x2, _y2);
    }
}

// Client Code
public class DrawingEditor
{
    public void DrawAllShapes(List<IShape> shapes)
    {
        foreach (var shape in shapes)
        {
            shape.Draw();
        }
    }
}

// Main Program
var shapes = new List<IShape>();
var legacyRect = new LegacyRectangle();
var adaptedRect = new ShapeAdapter(legacyRect, 10, 20, 100, 200);
shapes.Add(adaptedRect);

var editor = new DrawingEditor();
editor.DrawAllShapes(shapes);
// Output: Legacy Rectangle from (10,20) to (100,200)
</code></pre>
                                </div>
                            </div>
                        </div>

                        <div x-data="{ open: false }" class="bg-white border border-slate-200 rounded-lg shadow-sm my-6">
                            <button @click="open = !open" class="w-full text-left p-4 font-semibold text-slate-800 flex justify-between items-center">
                                <span>[Medium] Media Player Adapter</span>
                                <svg :class="{'rotate-180': open}" class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </button>
                            <div x-show="open" x-cloak class="p-4 border-t border-slate-200">
                                <p class="mb-4"><strong>Problem:</strong> Your application uses a standard `IMediaPlayer` interface to play audio files. You want to add support for more advanced formats (`.vlc`, `.mp4`) using a third-party library, `AdvancedMediaPlayer`, which has a different interface.</p>
                                <div class="bg-slate-800 text-white rounded-lg p-4 code-block">
                                    <button @click="copyToClipboard($event)" class="copy-button">Copy</button>
                                    <pre><code class="language-csharp">
// Target Interface
public interface IMediaPlayer
{
    void Play(string audioType, string fileName);
}

// Adaptee Interface and Concrete classes
public interface IAdvancedMediaPlayer
{
    void PlayVlc(string fileName);
    void PlayMp4(string fileName);
}

public class VlcPlayer : IAdvancedMediaPlayer
{
    public void PlayVlc(string fileName) => Console.WriteLine($"Playing vlc file. Name: {fileName}");
    public void PlayMp4(string fileName) { /* Do nothing */ }
}

public class Mp4Player : IAdvancedMediaPlayer
{
    public void PlayVlc(string fileName) { /* Do nothing */ }
    public void PlayMp4(string fileName) => Console.WriteLine($"Playing mp4 file. Name: {fileName}");
}


// Adapter Class
public class MediaPlayerAdapter : IMediaPlayer
{
    IAdvancedMediaPlayer _advancedMusicPlayer;

    public MediaPlayerAdapter(string audioType)
    {
        if (audioType.Equals("vlc", StringComparison.OrdinalIgnoreCase))
        {
            _advancedMusicPlayer = new VlcPlayer();
        }
        else if (audioType.Equals("mp4", StringComparison.OrdinalIgnoreCase))
        {
            _advancedMusicPlayer = new Mp4Player();
        }
    }

    public void Play(string audioType, string fileName)
    {
        if (audioType.Equals("vlc", StringComparison.OrdinalIgnoreCase))
        {
            _advancedMusicPlayer.PlayVlc(fileName);
        }
        else if (audioType.Equals("mp4", StringComparison.OrdinalIgnoreCase))
        {
            _advancedMusicPlayer.PlayMp4(fileName);
        }
    }
}

// Client (and original implementation)
public class AudioPlayer : IMediaPlayer
{
    public void Play(string audioType, string fileName)
    {
        if (audioType.Equals("mp3", StringComparison.OrdinalIgnoreCase))
        {
            Console.WriteLine($"Playing mp3 file. Name: {fileName}");
        }
        else if (audioType.Equals("vlc", StringComparison.OrdinalIgnoreCase) || audioType.Equals("mp4", StringComparison.OrdinalIgnoreCase))
        {
            var adapter = new MediaPlayerAdapter(audioType);
            adapter.Play(audioType, fileName);
        }
        else
        {
            Console.WriteLine($"Invalid media. {audioType} format not supported");
        }
    }
}

// Main Program
var audioPlayer = new AudioPlayer();
audioPlayer.Play("mp3", "beyond_the_horizon.mp3");
audioPlayer.Play("mp4", "alone.mp4");
audioPlayer.Play("vlc", "far_far_away.vlc");
audioPlayer.Play("avi", "mind_me.avi");
// Output:
// Playing mp3 file. Name: beyond_the_horizon.mp3
// Playing mp4 file. Name: alone.mp4
// Playing vlc file. Name: far_far_away.vlc
// Invalid media. avi format not supported
</code></pre>
                                </div>
                            </div>
                        </div>

                        <div x-data="{ open: true }" class="bg-white border border-slate-200 rounded-lg shadow-sm my-6">
                            <button @click="open = !open" class="w-full text-left p-4 font-semibold text-slate-800 flex justify-between items-center">
                                <span>[Hard] Payment Gateway Adapter</span>
                                <svg :class="{'rotate-180': open}" class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </button>
                            <div x-show="open" x-cloak class="p-4 border-t border-slate-200">
                                <p class="mb-4"><strong>Problem:</strong> An e-commerce site needs to integrate multiple payment gateways (e.g., Stripe, PayPal). Each gateway has a unique API for processing payments. The goal is to create a system where adding a new payment gateway doesn't require changing the core application logic.</p>
                                <div class="bg-slate-800 text-white rounded-lg p-4 code-block">
                                    <button @click="copyToClipboard($event)" class="copy-button">Copy</button>
                                    <pre><code class="language-csharp">
// Target Interface - The application's standard way to process payments
public interface IPaymentProcessor
{
    void ProcessPayment(decimal amount);
}

// --- Adaptee 1: Stripe ---
public class StripeGateway
{
    public void Charge(double total)
    {
        Console.WriteLine($"Charging ${total} via Stripe.");
    }
}

// Adapter for Stripe
public class StripeAdapter : IPaymentProcessor
{
    private readonly StripeGateway _stripeGateway;
    public StripeAdapter(StripeGateway stripeGateway) => _stripeGateway = stripeGateway;

    public void ProcessPayment(decimal amount)
    {
        _stripeGateway.Charge((double)amount);
    }
}

// --- Adaptee 2: PayPal ---
public class PayPalGateway
{
    public void SendPayment(decimal value)
    {
        Console.WriteLine($"Sending payment of ${value} through PayPal.");
    }
}

// Adapter for PayPal
public class PayPalAdapter : IPaymentProcessor
{
    private readonly PayPalGateway _payPalGateway;
    public PayPalAdapter(PayPalGateway payPalGateway) => _payPalGateway = payPalGateway;
    
    public void ProcessPayment(decimal amount)
    {
        _payPalGateway.SendPayment(amount);
    }
}

// --- Client Code ---
public class ShoppingCart
{
    public void Checkout(IPaymentProcessor paymentProcessor, decimal total)
    {
        Console.WriteLine("Starting checkout process...");
        paymentProcessor.ProcessPayment(total);
        Console.WriteLine("Checkout complete.");
    }
}

// Main Program
var cart = new ShoppingCart();
decimal orderTotal = 150.75m;

// Pay with Stripe
var stripe = new StripeGateway();
var stripeProcessor = new StripeAdapter(stripe);
cart.Checkout(stripeProcessor, orderTotal);

Console.WriteLine("\n--- Switching payment method ---\n");

// Pay with PayPal
var paypal = new PayPalGateway();
var paypalProcessor = new PayPalAdapter(paypal);
cart.Checkout(paypalProcessor, orderTotal);

// Output:
// Starting checkout process...
// Charging $150.75 via Stripe.
// Checkout complete.
// 
// --- Switching payment method ---
// 
// Starting checkout process...
// Sending payment of $150.75 through PayPal.
// Checkout complete.
</code></pre>
                                </div>
                            </div>
                        </div>
                    </section>
                    
                    <section id="case-study" class="scroll-mt-24 mt-12">
                        <h3>✅ Case Study / Machine Coding Exercise</h3>
                        <h4 class="font-semibold text-xl">Payment Gateway Adapter (Legacy vs. Modern APIs)</h4>
                        <p>This case study expands on the hard coding example, demonstrating how the Adapter pattern is essential for creating flexible, maintainable, and scalable systems, especially when dealing with third-party integrations.</p>

                        <div class="space-y-4">
                            <div>
                                <h5 class="font-bold">The Problem</h5>
                                <p>An e-commerce platform's business is growing. Initially, it only used Stripe for payments. The code was tightly coupled to the Stripe API. Now, they need to add PayPal to cater to more customers. The problem is that the PayPal API is completely different from Stripe's. How can they add PayPal (and potentially other gateways in the future) without rewriting the checkout logic every time?</p>
                            </div>

                            <div>
                                <h5 class="font-bold">The Solution: Applying the Adapter Pattern</h5>
                                <p>The solution is to decouple the application's checkout logic from the specific payment gateway implementations. We do this by defining a standard `IPaymentProcessor` interface. This becomes the single, consistent way the application processes payments. Then, for each payment gateway, we create a specific Adapter that implements `IPaymentProcessor` and translates its standard method calls into the specific API calls required by that gateway.</p>
                            </div>
                            
                            <div class="bg-zinc-100 p-4 rounded-lg border">
                                <h5 class="font-bold">Step-by-Step Breakdown</h5>
                                <ol class="list-decimal list-inside space-y-2 mt-2">
                                    <li><strong>Define the Target (`IPaymentProcessor`):</strong> Create an interface that represents the action our application understands, like `ProcessPayment(decimal amount)`. This is the contract our client code (the `ShoppingCart`) will use.</li>
                                    <li><strong>Identify the Adaptees (`StripeGateway`, `PayPalGateway`):</strong> These are the existing, third-party classes with their own unique, incompatible methods (`Charge`, `SendPayment`).</li>
                                    <li><strong>Implement the Adapters (`StripeAdapter`, `PayPalAdapter`):</strong> For each adaptee, create an adapter class.
                                        <ul class="list-disc list-inside ml-4">
                                            <li>`StripeAdapter` will take a `StripeGateway` object and, in its `ProcessPayment` method, it will call `_stripeGateway.Charge()`.</li>
                                            <li>`PayPalAdapter` will take a `PayPalGateway` object and, in its `ProcessPayment` method, it will call `_payPalGateway.SendPayment()`.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Update the Client (`ShoppingCart`):</strong> The `Checkout` method will now accept an object of type `IPaymentProcessor`. It doesn't know or care whether it's talking to Stripe, PayPal, or any other gateway. It just calls `ProcessPayment`, and the adapter handles the rest.</li>
                                </ol>
                            </div>
                            
                            <div>
                                <h5 class="font-bold">Benefits Realized</h5>
                                <ul class="list-disc list-inside space-y-2">
                                    <li><strong>Open/Closed Principle:</strong> The system is now open for extension (we can add new payment gateways by creating new adapters) but closed for modification (we don't need to change the existing `ShoppingCart` logic).</li>
                                    <li><strong>Single Responsibility Principle:</strong> The `ShoppingCart` is only responsible for the checkout flow. The adapters are responsible for the specific logic of communicating with each gateway.</li>
                                    <li><strong>Reduced Coupling:</strong> The core application is no longer tightly coupled to any specific third-party library.</li>
                                    <li><strong>Improved Testability:</strong> We can easily create a mock `IPaymentProcessor` to test the checkout logic without making real API calls.</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section id="scenarios" class="scroll-mt-24 mt-12">
                        <h3>🌍 Real-World Scenarios (As of Sept 2025)</h3>
                        <p>The Adapter pattern isn't just a theoretical concept; it's a pragmatic solution used every day by software engineers to build robust and maintainable systems. Here are some real-world scenarios where this pattern is indispensable today.</p>

                        <div class="bg-white border border-slate-200 rounded-lg shadow-sm my-6 p-4">
                            <h4 class="font-semibold text-lg text-slate-800">1. Integrating UPI Payments in Indian E-Commerce</h4>
                            <p class="mt-2"><strong>Context:</strong> An Indian shopping app, which was initially built with a standard credit card processing flow, needs to incorporate UPI—the dominant payment method in India.</p>
                            <p class="mt-2"><strong>The Problem (Incompatible Interfaces):</strong></p>
                            <ul class="list-disc list-inside ml-4 space-y-1">
                                <li>The app's existing interface might be a simple, synchronous `IPaymentGateway.ChargeCard(details, amount)`.</li>
                                <li>The UPI SDK (e.g., from Razorpay or Paytm) has a completely different, asynchronous, and intent-based API. It involves initiating a payment, waiting for a callback from the user's UPI app (like Google Pay or PhonePe), and then verifying the payment status.</li>
                            </ul>
                            <p class="mt-2"><strong>The Adapter Solution:</strong> An `UpiPaymentAdapter` is created. It implements the app's simple `IPaymentGateway` interface. When its `ChargeCard` method is called, the adapter doesn't charge a card. Instead, it kicks off the entire complex UPI flow: it generates a payment request, calls the UPI SDK, and handles the asynchronous callbacks, finally returning a success or failure status that the old system can understand. This allows the app to support UPI without a major rewrite of its checkout module. </p>
                        </div>

                        <div class="bg-white border border-slate-200 rounded-lg shadow-sm my-6 p-4">
                            <h4 class="font-semibold text-lg text-slate-800">2. Unifying Multiple Cloud Storage APIs</h4>
                            <p class="mt-2"><strong>Context:</strong> A modern SaaS platform like a 'Canva for Videos' needs to allow users to connect their cloud storage accounts (AWS S3, Google Cloud Storage, Azure Blob Storage) to import and export large video files.</p>
                             <p class="mt-2"><strong>The Problem (Incompatible Interfaces):</strong></p>
                             <ul class="list-disc list-inside ml-4 space-y-1">
                                <li>The AWS S3 SDK has methods like `PutObjectAsync`.</li>
                                <li>The Google Cloud Storage SDK uses a `storage.Bucket("...").UploadObjectAsync(...)` pattern.</li>
                                <li>Azure's SDK uses a `BlobClient.UploadAsync`.</li>
                             </ul>
                            <p class="mt-2"><strong>The Adapter Solution:</strong> The platform defines its own generic `ICloudStorageProvider` interface with methods like `UploadFileAsync(stream, fileName)` and `GetDownloadUrlAsync(fileName)`. Then, it implements `AwsS3Adapter`, `GcsAdapter`, and `AzureBlobAdapter`. Each adapter class contains the specific, boilerplate code required to interact with its respective cloud SDK. The core application logic can now work with any cloud provider through a single, clean interface, making the code much easier to manage and extend to other providers like DigitalOcean Spaces in the future.</p>
                        </div>

                        <div class="bg-white border border-slate-200 rounded-lg shadow-sm my-6 p-4">
                            <h4 class="font-semibold text-lg text-slate-800">3. Modernizing Legacy Financial Systems</h4>
                            <p class="mt-2"><strong>Context:</strong> A large Indian bank is undergoing a digital transformation. They are building new mobile banking microservices that communicate using modern REST APIs with JSON payloads.</p>
                            <p class="mt-2"><strong>The Problem (Incompatible Data Formats):</strong> The bank's Core Banking System (CBS) is a 20-year-old mainframe that cannot be replaced. It communicates by exposing data in legacy formats like fixed-width text files (EBCDIC) or XML over a message queue.</p>
                            <p class="mt-2"><strong>The Adapter Solution:</strong> An "Anti-Corruption Layer" (a form of adapter) is built as a separate microservice. This `LegacyCbsAdapter` exposes a clean RESTful API to the new mobile services (e.g., `GET /api/v1/accounts/{id}`). When this endpoint is hit, the adapter service makes the complex, old-style call to the mainframe, receives the cryptic fixed-width data, parses it, transforms it into a clean JSON object, and then returns that JSON to the mobile service. It adapts the legacy data format and protocol into a modern one, protecting the new system from the complexity of the old.</p>
                        </div>

                    </section>

                    <section id="quiz" class="scroll-mt-24 mt-12">
                         <h3>🧠 Knowledge Check Quiz</h3>
                        <p>Test your understanding of the Adapter pattern with these questions.</p>
                        <div class="space-y-6">
                            <template x-for="(quiz, index) in quizzes" :key="index">
                                <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                                    <p class="font-semibold mb-4"><span x-text="index + 1"></span>. <span x-text="quiz.question"></span></p>
                                    <div class="space-y-3">
                                        <template x-for="(option, optionIndex) in quiz.options" :key="optionIndex">
                                            <div @click="selectOption(index, optionIndex)"
                                                 class="quiz-option p-3 border-2 border-slate-200 rounded-lg cursor-pointer transition-colors"
                                                 :data-selected="quiz.selected === optionIndex"
                                                 :data-correct="quiz.answered && quiz.correct === optionIndex">
                                                <span x-text="option"></span>
                                            </div>
                                        </template>
                                    </div>
                                    <div x-show="quiz.answered" class="mt-4">
                                        <p x-show="quiz.selected === quiz.correct" class="text-green-700 font-semibold">Correct! <span x-text="quiz.feedback"></span></p>
                                        <p x-show="quiz.selected !== quiz.correct" class="text-red-700 font-semibold">Incorrect. <span x-text="quiz.feedback"></span></p>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </section>

                    <section id="challenge" class="scroll-mt-24 mt-12">
                        <h3>🚀 Self-Assessment Challenge</h3>
                        <p>Ready to apply your knowledge? Tackle this challenge to build your own adapter from scratch.</p>
                        <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                            <h4 class="font-semibold text-lg">The Logging Service Adapter</h4>
                            <p class="mt-2"><strong>Scenario:</strong> Your application has a standardized `ILogger` interface that all components use for logging messages. The interface is simple:</p>
                            <div class="bg-slate-800 text-white rounded-lg p-2 my-2 text-sm">
                                <pre><code>public interface ILogger { void Log(string message); }</code></pre>
                            </div>
                            <p class="mt-2">Your team has decided to integrate a new, powerful, but third-party logging service called `SuperLog`. Unfortunately, its API is different:</p>
                            <div class="bg-slate-800 text-white rounded-lg p-2 my-2 text-sm">
                                <pre><code>public class SuperLog { public void LogMessage(string message, int severity); }</code></pre>
                            </div>
                            <p class="mt-2"><strong>Your Task:</strong> Create an adapter named `SuperLogAdapter` that allows the rest of your application to use the `SuperLog` service through the existing `ILogger` interface. For simplicity, assume all logs sent through your adapter should have a default severity level of `1`.</p>
                            
                            <div x-data="{ open: false }" class="mt-6">
                                <button @click="open = !open" class="bg-amber-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-600 transition-colors">
                                    <span x-show="!open">Show Solution</span>
                                    <span x-show="open">Hide Solution</span>
                                </button>
                                <div x-show="open" x-cloak class="mt-4 border-t pt-4">
                                    <h5 class="font-bold mb-2">Challenge Solution:</h5>
                                    <div class="bg-slate-800 text-white rounded-lg p-4 code-block">
                                        <button @click="copyToClipboard($event)" class="copy-button">Copy</button>
                                        <pre><code class="language-csharp">
// Standard Application Interface (Target)
public interface ILogger
{
    void Log(string message);
}

// Our application's logger
public class AppLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[AppLog]: {message}");
    }
}

// 3rd Party Service (Adaptee)
public class SuperLog
{
    public void LogMessage(string message, int severity)
    {
        Console.WriteLine($"[SuperLog | Severity {severity}]: {message}");
    }
}

// The Adapter
public class SuperLogAdapter : ILogger
{
    private readonly SuperLog _superLog;
    private const int DefaultSeverity = 1;

    public SuperLogAdapter(SuperLog superLog)
    {
        _superLog = superLog;
    }

    public void Log(string message)
    {
        // Translate the Log() call to LogMessage() with default severity
        _superLog.LogMessage(message, DefaultSeverity);
    }
}

// Client Code
public class DataProcessor
{
    private readonly ILogger _logger;

    public DataProcessor(ILogger logger)
    {
        _logger = logger;
    }

    public void Process()
    {
        _logger.Log("Starting data processing...");
        // ... processing logic ...
        _logger.Log("Data processing finished.");
    }
}

// Main Program
// Using the standard logger
var standardLogger = new AppLogger();
var processor1 = new DataProcessor(standardLogger);
processor1.Process();

Console.WriteLine("\n--- Switching to SuperLog service ---\n");

// Now, using the new SuperLog service via the adapter
var superLogService = new SuperLog();
var adaptedLogger = new SuperLogAdapter(superLogService);
var processor2 = new DataProcessor(adaptedLogger);
processor2.Process();

// Output:
// [AppLog]: Starting data processing...
// [AppLog]: Data processing finished.
//
// --- Switching to SuperLog service ---
//
// [SuperLog | Severity 1]: Starting data processing...
// [SuperLog | Severity 1]: Data processing finished.
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </article>
            </div>

            <!-- Sticky TOC -->
            <div class="w-full lg:w-1/4">
                <aside class="sticky top-24">
                    <h3 class="font-semibold text-slate-800 font-lexend mb-4">On This Page</h3>
                    <nav>
                        <ul id="toc" class="space-y-2">
                            <li><a href="#theory" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">Theory Topics</a></li>
                            <li><a href="#uml" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">UML/Schema Task</a></li>
                            <li><a href="#coding-practice" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">Coding Practice</a></li>
                            <li><a href="#case-study" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">Case Study</a></li>
                            <li><a href="#scenarios" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">Real-World Scenarios</a></li>
                            <li><a href="#quiz" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">Knowledge Check</a></li>
                            <li><a href="#challenge" class="toc-link block text-slate-600 border-l-2 border-slate-200 pl-4 hover:text-amber-600 hover:border-amber-600 transition-colors">Self-Assessment Challenge</a></li>
                        </ul>
                    </nav>
                </aside>
            </div>
        </div>
    </main>

    <footer class="text-center mt-16 py-8 border-t border-slate-200">
        <p class="text-slate-700 font-semibold">Low-Level Design Bootcamp</p>
        <p class="text-sm text-slate-500 mt-2">A personalized learning roadmap curated by Mr. Mahesh Singare.</p>
        <p class="text-xs text-slate-400 mt-4">&copy; 2025. All Rights Reserved.</p>
    </footer>

    <script>
    function adapterPatternPage() {
        return {
            quizzes: [
                {
                    question: "What is the primary intent of the Adapter pattern?",
                    options: [
                        "To provide a simplified interface to a complex system.",
                        "To convert the interface of a class into another interface clients expect.",
                        "To define a family of algorithms, encapsulate each one, and make them interchangeable.",
                        "To attach additional responsibilities to an object dynamically."
                    ],
                    correct: 1,
                    selected: null,
                    answered: false,
                    feedback: "The Adapter's main purpose is to make incompatible interfaces work together."
                },
                {
                    question: "In the Adapter pattern, what is the role of the 'Adaptee'?",
                    options: [
                        "The interface that the client code uses.",
                        "The class that performs the interface translation.",
                        "The existing class with an incompatible interface that needs to be adapted.",
                        "The client code that needs to use the adaptee."
                    ],
                    correct: 2,
                    selected: null,
                    answered: false,
                    feedback: "The Adaptee is the class we want to use, but whose interface doesn't match what the client expects."
                },
                 {
                    question: "Which of the following scenarios is the BEST fit for the Adapter pattern?",
                    options: [
                        "You need to create objects without specifying the exact class of object that will be created.",
                        "You want to allow a group of objects to be notified when some state changes.",
                        "You need to integrate a third-party library with a different API into your existing application.",
                        "You need to ensure a class has only one instance and provide a global point of access to it."
                    ],
                    correct: 2,
                    selected: null,
                    answered: false,
                    feedback: "Integrating existing components, like third-party or legacy systems, is a classic use case for the Adapter pattern."
                },
                {
                    question: "How is the Adapter pattern different from the Facade pattern?",
                    options: [
                        "There is no difference; they are two names for the same pattern.",
                        "Adapter changes an interface, while Facade simplifies a set of interfaces.",
                        "Facade is a creational pattern, while Adapter is structural.",
                        "Adapter works with multiple objects, while Facade only wraps one."
                    ],
                    correct: 1,
                    selected: null,
                    answered: false,
                    feedback: "The key difference is intent: Adapter is about changing an interface, while Facade is about simplifying one."
                },
                 {
                    question: "The Adapter pattern helps adhere to which SOLID principle?",
                    options: [
                        "Single Responsibility Principle",
                        "Liskov Substitution Principle",
                        "Open/Closed Principle",
                        "All of the above"
                    ],
                    correct: 2,
                    selected: null,
                    answered: false,
                    feedback: "It strongly supports the Open/Closed Principle, as you can introduce new adapters for new classes without modifying the client code."
                }
            ],

            selectOption(quizIndex, optionIndex) {
                if (this.quizzes[quizIndex].answered) return;
                this.quizzes[quizIndex].selected = optionIndex;
                this.quizzes[quizIndex].answered = true;
            },

            copyToClipboard(event) {
                const button = event.currentTarget;
                const pre = button.parentElement.querySelector('pre');
                const code = pre.innerText;
                navigator.clipboard.writeText(code).then(() => {
                    button.innerText = 'Copied!';
                    setTimeout(() => {
                        button.innerText = 'Copy';
                    }, 2000);
                });
            },

            init() {
                const tocLinks = document.querySelectorAll('.toc-link');
                const sections = document.querySelectorAll('section[id]');

                const observer = new IntersectionObserver(entries => {
                    entries.forEach(entry => {
                        const id = entry.target.getAttribute('id');
                        const tocLink = document.querySelector(`.toc-link[href="#${id}"]`);
                        
                        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
                            tocLinks.forEach(link => link.classList.remove('active'));
                            tocLink.classList.add('active');
                        }
                    });
                }, { rootMargin: '0px', threshold: 0.5 });

                sections.forEach(section => {
                    observer.observe(section);
                });
            }
        }
    }
    </script>

</body>
</html>

